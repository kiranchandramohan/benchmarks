cc -I/usr/include/libdrm -I/usr/include/omap -Wall -O2 -fstrict-aliasing -mfpu=neon -ftree-vectorize -ftree-vectorizer-verbose=10 -c -o timer.o timer.c
cc -I/usr/include/libdrm -I/usr/include/omap -Wall -O2 -fstrict-aliasing -mfpu=neon -ftree-vectorize -ftree-vectorizer-verbose=10 -c -o barrier.o barrier.c
cc -I/usr/include/libdrm -I/usr/include/omap -Wall -O2 -fstrict-aliasing -mfpu=neon -ftree-vectorize -ftree-vectorizer-verbose=10 -c -o util.o util.c

util.c:81: note: ===== analyze_loop_nest =====
util.c:81: note: === vect_analyze_loop_form ===
util.c:81: note: ===== analyze_loop_nest_1 =====
util.c:81: note: === vect_analyze_loop_form ===
util.c:81: note: not vectorized: control flow in loop.
util.c:81: note: bad inner-loop form.
util.c:81: note: not vectorized: Bad inner loop.
util.c:81: note: bad loop form.
util.c:68: note: ===== analyze_loop_nest =====
util.c:68: note: === vect_analyze_loop_form ===
util.c:68: note: not vectorized: control flow in loop.
util.c:68: note: bad loop form.
util.c:78: note: vectorized 0 loops in function.
cc -I/usr/include/libdrm -I/usr/include/omap -Wall -O2 -fstrict-aliasing -mfpu=neon -ftree-vectorize -ftree-vectorizer-verbose=10 -c -o simpletest.o simpletest.c

simpletest.c:78: note: ===== analyze_loop_nest =====
simpletest.c:78: note: === vect_analyze_loop_form ===
simpletest.c:78: note: not vectorized: control flow in loop.
simpletest.c:78: note: bad loop form.
simpletest.c:75: note: vectorized 0 loops in function.

simpletest.c:114: note: ===== analyze_loop_nest =====
simpletest.c:114: note: === vect_analyze_loop_form ===
simpletest.c:114: note: ===== analyze_loop_nest_1 =====
simpletest.c:114: note: === vect_analyze_loop_form ===
simpletest.c:114: note: split exit edge.
simpletest.c:114: note: === get_loop_niters ===
simpletest.c:114: note: not vectorized: number of iterations cannot be computed.
simpletest.c:114: note: bad inner-loop form.
simpletest.c:114: note: not vectorized: Bad inner loop.
simpletest.c:114: note: bad loop form.
simpletest.c:115: note: ===== analyze_loop_nest =====
simpletest.c:115: note: === vect_analyze_loop_form ===
simpletest.c:115: note: === get_loop_niters ===
simpletest.c:115: note: not vectorized: number of iterations cannot be computed.
simpletest.c:115: note: bad loop form.
simpletest.c:111: note: vectorized 0 loops in function.

simpletest.c:126: note: ===== analyze_loop_nest =====
simpletest.c:126: note: === vect_analyze_loop_form ===
simpletest.c:126: note: === get_loop_niters ===
simpletest.c:126: note: ==> get_loop_niters:(unsigned int) nbuf_4(D)
simpletest.c:126: note: Symbolic number of iterations is (unsigned int) nbuf_4(D)
simpletest.c:126: note: === vect_analyze_data_refs ===

simpletest.c:126: note: not vectorized: loop contains function calls or data references that cannot be analyzed
simpletest.c:126: note: bad data references.
simpletest.c:122: note: vectorized 0 loops in function.

simpletest.c:151: note: ===== analyze_loop_nest =====
simpletest.c:151: note: === vect_analyze_loop_form ===
simpletest.c:151: note: ===== analyze_loop_nest_1 =====
simpletest.c:151: note: === vect_analyze_loop_form ===
simpletest.c:151: note: split exit edge.
simpletest.c:151: note: === get_loop_niters ===
simpletest.c:151: note: not vectorized: number of iterations cannot be computed.
simpletest.c:151: note: bad inner-loop form.
simpletest.c:151: note: not vectorized: Bad inner loop.
simpletest.c:151: note: bad loop form.
simpletest.c:152: note: ===== analyze_loop_nest =====
simpletest.c:152: note: === vect_analyze_loop_form ===
simpletest.c:152: note: === get_loop_niters ===
simpletest.c:152: note: not vectorized: number of iterations cannot be computed.
simpletest.c:152: note: bad loop form.
simpletest.c:133: note: vectorized 0 loops in function.

simpletest.c:274: note: ===== analyze_loop_nest =====
simpletest.c:274: note: === vect_analyze_loop_form ===
simpletest.c:274: note: not vectorized: control flow in loop.
simpletest.c:274: note: bad loop form.
simpletest.c:267: note: vectorized 0 loops in function.

simpletest.c:375: note: ===== analyze_loop_nest =====
simpletest.c:375: note: === vect_analyze_loop_form ===
simpletest.c:375: note: === get_loop_niters ===
simpletest.c:375: note: ==> get_loop_niters:(unsigned int) D.7417_5 + 1
simpletest.c:375: note: Symbolic number of iterations is (unsigned int) D.7417_5 + 1
simpletest.c:375: note: === vect_analyze_data_refs ===

simpletest.c:375: note: get vectype with 16 units of type char
simpletest.c:375: note: vectype: vector(16) char
simpletest.c:375: note: === vect_analyze_scalar_cycles ===
simpletest.c:375: note: Analyze phi: delim_indx_25 = PHI <delim_indx_1(5), -1(3)>

simpletest.c:375: note: Access function of PHI: delim_indx_25
simpletest.c:375: note: Analyze phi: i_39 = PHI <i_15(5), 0(3)>

simpletest.c:375: note: Access function of PHI: {0, +, 1}_1
simpletest.c:375: note: step: 1,  init: 0
simpletest.c:375: note: Detected induction.
simpletest.c:375: note: Analyze phi: delim_indx_25 = PHI <delim_indx_1(5), -1(3)>

simpletest.c:375: note: reduction: not commutative/associative: delim_indx_1 = [cond_expr] D.7421_12 != delim_13(D) ? delim_indx_25 : i_39;

simpletest.c:375: note: Unknown def-use cycle pattern.
simpletest.c:375: note: === vect_pattern_recog ===
simpletest.c:375: note: get vectype with 16 units of type char
simpletest.c:375: note: vectype: vector(16) char
simpletest.c:375: note: vect_is_simple_use: operand delim_indx_25
simpletest.c:375: note: def_stmt: delim_indx_25 = PHI <delim_indx_1(5), -1(3)>

simpletest.c:375: note: Unsupported pattern.
simpletest.c:375: note: === vect_mark_stmts_to_be_vectorized ===
simpletest.c:375: note: init: phi relevant? delim_indx_25 = PHI <delim_indx_1(5), -1(3)>

simpletest.c:375: note: init: phi relevant? i_39 = PHI <i_15(5), 0(3)>

simpletest.c:375: note: init: stmt relevant? i.20_10 = (unsigned int) i_39;

simpletest.c:375: note: init: stmt relevant? D.7420_11 = str_4(D) + i.20_10;

simpletest.c:375: note: init: stmt relevant? D.7421_12 = *D.7420_11;

simpletest.c:375: note: init: stmt relevant? D.8110_81 = D.7421_12 != delim_13(D);

simpletest.c:375: note: init: stmt relevant? delim_indx_1 = [cond_expr] D.7421_12 != delim_13(D) ? delim_indx_25 : i_39;

simpletest.c:375: note: vec_stmt_relevant_p: used out of loop.
simpletest.c:375: note: mark relevant 0, live 1.
simpletest.c:375: note: init: stmt relevant? i_15 = i_39 + 1;

simpletest.c:375: note: init: stmt relevant? if (len_6 >= i_15)

simpletest.c:375: note: worklist: examine stmt: delim_indx_1 = [cond_expr] D.7421_12 != delim_13(D) ? delim_indx_25 : i_39;

simpletest.c:375: note: vect_is_simple_use: operand D.7421_12
simpletest.c:375: note: def_stmt: D.7421_12 = *D.7420_11;

simpletest.c:375: note: type of def: 3.
simpletest.c:375: note: mark relevant 0, live 1.
simpletest.c:375: note: vect_is_simple_use: operand delim_13(D)
simpletest.c:375: note: def_stmt: GIMPLE_NOP

simpletest.c:375: note: vect_is_simple_use: operand delim_indx_25
simpletest.c:375: note: def_stmt: delim_indx_25 = PHI <delim_indx_1(5), -1(3)>

simpletest.c:375: note: Unsupported pattern.
simpletest.c:375: note: not vectorized: unsupported use in stmt.
simpletest.c:375: note: unexpected pattern.
simpletest.c:375: note: ***** Re-trying analysis with vector size 8

simpletest.c:375: note: === vect_analyze_loop_form ===
simpletest.c:375: note: === get_loop_niters ===
simpletest.c:375: note: ==> get_loop_niters:(unsigned int) D.7417_5 + 1
simpletest.c:375: note: Symbolic number of iterations is (unsigned int) D.7417_5 + 1
simpletest.c:375: note: === vect_analyze_data_refs ===

simpletest.c:375: note: get vectype with 8 units of type char
simpletest.c:375: note: vectype: vector(8) char
simpletest.c:375: note: === vect_analyze_scalar_cycles ===
simpletest.c:375: note: Analyze phi: delim_indx_25 = PHI <delim_indx_1(5), -1(3)>

simpletest.c:375: note: Access function of PHI: delim_indx_25
simpletest.c:375: note: Analyze phi: i_39 = PHI <i_15(5), 0(3)>

simpletest.c:375: note: Access function of PHI: {0, +, 1}_1
simpletest.c:375: note: step: 1,  init: 0
simpletest.c:375: note: Detected induction.
simpletest.c:375: note: Analyze phi: delim_indx_25 = PHI <delim_indx_1(5), -1(3)>

simpletest.c:375: note: reduction: not commutative/associative: delim_indx_1 = [cond_expr] D.7421_12 != delim_13(D) ? delim_indx_25 : i_39;

simpletest.c:375: note: Unknown def-use cycle pattern.
simpletest.c:375: note: === vect_pattern_recog ===
simpletest.c:375: note: get vectype with 8 units of type char
simpletest.c:375: note: vectype: vector(8) char
simpletest.c:375: note: vect_is_simple_use: operand delim_indx_25
simpletest.c:375: note: def_stmt: delim_indx_25 = PHI <delim_indx_1(5), -1(3)>

simpletest.c:375: note: Unsupported pattern.
simpletest.c:375: note: === vect_mark_stmts_to_be_vectorized ===
simpletest.c:375: note: init: phi relevant? delim_indx_25 = PHI <delim_indx_1(5), -1(3)>

simpletest.c:375: note: init: phi relevant? i_39 = PHI <i_15(5), 0(3)>

simpletest.c:375: note: init: stmt relevant? i.20_10 = (unsigned int) i_39;

simpletest.c:375: note: init: stmt relevant? D.7420_11 = str_4(D) + i.20_10;

simpletest.c:375: note: init: stmt relevant? D.7421_12 = *D.7420_11;

simpletest.c:375: note: init: stmt relevant? D.8110_81 = D.7421_12 != delim_13(D);

simpletest.c:375: note: init: stmt relevant? delim_indx_1 = [cond_expr] D.7421_12 != delim_13(D) ? delim_indx_25 : i_39;

simpletest.c:375: note: vec_stmt_relevant_p: used out of loop.
simpletest.c:375: note: mark relevant 0, live 1.
simpletest.c:375: note: init: stmt relevant? i_15 = i_39 + 1;

simpletest.c:375: note: init: stmt relevant? if (len_6 >= i_15)

simpletest.c:375: note: worklist: examine stmt: delim_indx_1 = [cond_expr] D.7421_12 != delim_13(D) ? delim_indx_25 : i_39;

simpletest.c:375: note: vect_is_simple_use: operand D.7421_12
simpletest.c:375: note: def_stmt: D.7421_12 = *D.7420_11;

simpletest.c:375: note: type of def: 3.
simpletest.c:375: note: mark relevant 0, live 1.
simpletest.c:375: note: vect_is_simple_use: operand delim_13(D)
simpletest.c:375: note: def_stmt: GIMPLE_NOP

simpletest.c:375: note: vect_is_simple_use: operand delim_indx_25
simpletest.c:375: note: def_stmt: delim_indx_25 = PHI <delim_indx_1(5), -1(3)>

simpletest.c:375: note: Unsupported pattern.
simpletest.c:375: note: not vectorized: unsupported use in stmt.
simpletest.c:375: note: unexpected pattern.
simpletest.c:362: note: vectorized 0 loops in function.

simpletest.c:410: note: ===== analyze_loop_nest =====
simpletest.c:410: note: === vect_analyze_loop_form ===
simpletest.c:410: note: not vectorized: control flow in loop.
simpletest.c:410: note: bad loop form.
simpletest.c:392: note: vectorized 0 loops in function.

simpletest.c:463: note: ===== analyze_loop_nest =====
simpletest.c:463: note: === vect_analyze_loop_form ===
simpletest.c:463: note: ===== analyze_loop_nest_1 =====
simpletest.c:463: note: === vect_analyze_loop_form ===
simpletest.c:463: note: not vectorized: control flow in loop.
simpletest.c:463: note: bad inner-loop form.
simpletest.c:463: note: not vectorized: Bad inner loop.
simpletest.c:463: note: bad loop form.
simpletest.c:474: note: ===== analyze_loop_nest =====
simpletest.c:474: note: === vect_analyze_loop_form ===
simpletest.c:474: note: not vectorized: control flow in loop.
simpletest.c:474: note: bad loop form.
simpletest.c:454: note: vectorized 0 loops in function.

simpletest.c:575: note: ===== analyze_loop_nest =====
simpletest.c:575: note: === vect_analyze_loop_form ===
simpletest.c:575: note: === get_loop_niters ===
simpletest.c:575: note: ==> get_loop_niters:(unsigned int) num_a9_threads_34(D)
simpletest.c:575: note: Symbolic number of iterations is (unsigned int) num_a9_threads_34(D)
simpletest.c:575: note: === vect_analyze_data_refs ===

simpletest.c:575: note: not vectorized: loop contains function calls or data references that cannot be analyzed
simpletest.c:575: note: bad data references.
simpletest.c:563: note: ===== analyze_loop_nest =====
simpletest.c:563: note: === vect_analyze_loop_form ===
simpletest.c:563: note: not vectorized: control flow in loop.
simpletest.c:563: note: bad loop form.
simpletest.c:504: note: vectorized 0 loops in function.

simpletest.c:661: note: ===== analyze_loop_nest =====
simpletest.c:661: note: === vect_analyze_loop_form ===
simpletest.c:661: note: === get_loop_niters ===
simpletest.c:661: note: ==> get_loop_niters:90
simpletest.c:661: note: === vect_analyze_data_refs ===

simpletest.c:661: note: not vectorized: loop contains function calls or data references that cannot be analyzed
simpletest.c:661: note: bad data references.
simpletest.c:627: note: ===== analyze_loop_nest =====
simpletest.c:627: note: === vect_analyze_loop_form ===
simpletest.c:627: note: not vectorized: control flow in loop.
simpletest.c:627: note: bad loop form.
simpletest.c:588: note: vectorized 0 loops in function.
cc -I/usr/include/libdrm -I/usr/include/omap -Wall -O2 -fstrict-aliasing -mfpu=neon -ftree-vectorize -ftree-vectorizer-verbose=10 -c -o test.o test.c
test.c: In function ‘compute_gray_level_mapping’:
test.c:113:8: warning: unused variable ‘tmp1’ [-Wunused-variable]
test.c: In function ‘a9_compute’:
test.c:180:9: warning: unused variable ‘j’ [-Wunused-variable]
test.c: In function ‘verify_result’:
test.c:272:6: warning: unused variable ‘pass’ [-Wunused-variable]
test.c:271:9: warning: unused variable ‘j’ [-Wunused-variable]
test.c:271:6: warning: unused variable ‘i’ [-Wunused-variable]

test.c:37: note: ===== analyze_loop_nest =====
test.c:37: note: === vect_analyze_loop_form ===
test.c:37: note: ===== analyze_loop_nest_1 =====
test.c:37: note: === vect_analyze_loop_form ===
test.c:37: note: === get_loop_niters ===
test.c:37: note: ==> get_loop_niters:4096
test.c:37: note: Considering outer-loop vectorization.
test.c:37: note: split exit edge.
test.c:37: note: === get_loop_niters ===
test.c:37: note: ==> get_loop_niters:((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:37: note: Symbolic number of iterations is ((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:37: note: === vect_analyze_data_refs ===

test.c:37: note: analyze in outer-loop: *((int * restrict) D.7152_10 + (unsigned int) ((unsigned int) i_71 * 16384))
test.c:37: note: 	outer base_address: (int *) D.7152_10 + (unsigned int) ((unsigned int) img_start_indx_21(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:37: note: get vectype with 4 units of type int
test.c:37: note: vectype: vector(4) int
test.c:37: note: not vectorized: data ref analysis failed D.7169_48 = *D.7168_47;

test.c:37: note: bad data references.
test.c:37: note: ***** Re-trying analysis with vector size 8

test.c:37: note: === vect_analyze_loop_form ===
test.c:37: note: ===== analyze_loop_nest_1 =====
test.c:37: note: === vect_analyze_loop_form ===
test.c:37: note: === get_loop_niters ===
test.c:37: note: ==> get_loop_niters:4096
test.c:37: note: Considering outer-loop vectorization.
test.c:37: note: === get_loop_niters ===
test.c:37: note: ==> get_loop_niters:((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:37: note: Symbolic number of iterations is ((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:37: note: === vect_analyze_data_refs ===

test.c:37: note: analyze in outer-loop: *((int * restrict) D.7152_10 + (unsigned int) ((unsigned int) i_71 * 16384))
test.c:37: note: 	outer base_address: (int *) D.7152_10 + (unsigned int) ((unsigned int) img_start_indx_21(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:37: note: get vectype with 2 units of type int
test.c:37: note: vectype: vector(2) int
test.c:37: note: not vectorized: data ref analysis failed D.7169_48 = *D.7168_47;

test.c:37: note: bad data references.
test.c:38: note: ===== analyze_loop_nest =====
test.c:38: note: === vect_analyze_loop_form ===
test.c:38: note: === get_loop_niters ===
test.c:38: note: ==> get_loop_niters:4096
test.c:38: note: === vect_analyze_data_refs ===

test.c:38: note: get vectype with 4 units of type int
test.c:38: note: vectype: vector(4) int
test.c:38: note: not vectorized: data ref analysis failed D.7169_48 = *D.7168_47;

test.c:38: note: bad data references.
test.c:38: note: ***** Re-trying analysis with vector size 8

test.c:38: note: === vect_analyze_loop_form ===
test.c:38: note: === get_loop_niters ===
test.c:38: note: ==> get_loop_niters:4096
test.c:38: note: === vect_analyze_data_refs ===

test.c:38: note: get vectype with 2 units of type int
test.c:38: note: vectype: vector(2) int
test.c:38: note: not vectorized: data ref analysis failed D.7169_48 = *D.7168_47;

test.c:38: note: bad data references.
test.c:30: note: ===== analyze_loop_nest =====
test.c:30: note: === vect_analyze_loop_form ===
test.c:30: note: ===== analyze_loop_nest_1 =====
test.c:30: note: === vect_analyze_loop_form ===
test.c:30: note: === get_loop_niters ===
test.c:30: note: ==> get_loop_niters:4096
test.c:30: note: Considering outer-loop vectorization.
test.c:30: note: === get_loop_niters ===
test.c:30: note: ==> get_loop_niters:((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:30: note: Symbolic number of iterations is ((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:30: note: === vect_analyze_data_refs ===

test.c:30: note: analyze in outer-loop: *((int * restrict) D.7152_10 + (unsigned int) ((unsigned int) i_63 * 16384))
test.c:30: note: 	outer base_address: (int *) D.7152_10 + (unsigned int) ((unsigned int) img_start_indx_21(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:30: note: get vectype with 4 units of type int
test.c:30: note: vectype: vector(4) int
test.c:30: note: === vect_analyze_scalar_cycles ===
test.c:30: note: Analyze phi: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: Access function of PHI: {img_start_indx_21(D), +, 1}_2
test.c:30: note: step: 1,  init: img_start_indx_21(D)
test.c:30: note: Detected induction.
test.c:30: note: Analyze phi: .MEM_54 = PHI <.MEM_60(9), .MEM_59(17)>

test.c:30: note: === vect_analyze_scalar_cycles ===
test.c:30: note: Analyze phi: j_69 = PHI <j_32(6), 0(18)>

test.c:30: note: Access function of PHI: {0, +, 1}_3
test.c:30: note: step: 1,  init: 0
test.c:30: note: Detected induction.
test.c:30: note: Analyze phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:30: note: Analyze phi: ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:30: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:30: note: step: 4294967295,  init: 4096
test.c:30: note: Detected induction.
test.c:30: note: === vect_pattern_recog ===
test.c:30: note: vect_is_simple_use: operand i_63
test.c:30: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: type of def: 4.
test.c:30: note: vect_is_simple_use: operand D.7161_27
test.c:30: note: def_stmt: D.7161_27 = (unsigned int) D.7160_26;

test.c:30: note: type of def: 3.
test.c:30: note: vect_is_simple_use: operand i_63
test.c:30: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: type of def: 4.
test.c:30: note: === vect_mark_stmts_to_be_vectorized ===
test.c:30: note: init: phi relevant? i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: init: phi relevant? .MEM_54 = PHI <.MEM_60(9), .MEM_59(17)>

test.c:30: note: init: stmt relevant? pretmp.44_110 = i_63 * 4096;

test.c:30: note: init: phi relevant? j_69 = PHI <j_32(6), 0(18)>

test.c:30: note: init: phi relevant? .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:30: note: init: phi relevant? ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:30: note: init: stmt relevant? D.7160_26 = j_69 + pretmp.44_110;

test.c:30: note: init: stmt relevant? D.7161_27 = (unsigned int) D.7160_26;

test.c:30: note: init: stmt relevant? D.7162_28 = D.7161_27 * 4;

test.c:30: note: init: stmt relevant? D.7163_29 = image_11 + D.7162_28;

test.c:30: note: init: stmt relevant? D.7164_30 = i_63 * j_69;

test.c:30: note: init: stmt relevant? D.7165_31 = D.7164_30 % 255;

test.c:30: note: init: stmt relevant? *D.7163_29 = D.7165_31;

test.c:30: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: init: stmt relevant? j_32 = j_69 + 1;

test.c:30: note: init: stmt relevant? ivtmp.46_113 = ivtmp.46_115 - 1;

test.c:30: note: init: stmt relevant? if (ivtmp.46_113 != 0)

test.c:30: note: init: stmt relevant? i_33 = i_63 + 1;

test.c:30: note: init: stmt relevant? if (img_end_indx_23(D) > i_33)

test.c:30: note: worklist: examine stmt: *D.7163_29 = D.7165_31;

test.c:30: note: vect_is_simple_use: operand D.7165_31
test.c:30: note: def_stmt: D.7165_31 = D.7164_30 % 255;

test.c:30: note: type of def: 3.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: worklist: examine stmt: D.7165_31 = D.7164_30 % 255;

test.c:30: note: vect_is_simple_use: operand D.7164_30
test.c:30: note: def_stmt: D.7164_30 = i_63 * j_69;

test.c:30: note: type of def: 3.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: worklist: examine stmt: D.7164_30 = i_63 * j_69;

test.c:30: note: vect_is_simple_use: operand i_63
test.c:30: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: type of def: 4.
test.c:30: note: outer-loop def-stmt defining inner-loop stmt.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: vect_is_simple_use: operand j_69
test.c:30: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:30: note: type of def: 4.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: worklist: examine stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:30: note: vect_is_simple_use: operand j_32
test.c:30: note: def_stmt: j_32 = j_69 + 1;

test.c:30: note: type of def: 3.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: vect_is_simple_use: operand 0
test.c:30: note: worklist: examine stmt: j_32 = j_69 + 1;

test.c:30: note: vect_is_simple_use: operand j_69
test.c:30: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:30: note: type of def: 4.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: already marked relevant/live.
test.c:30: note: worklist: examine stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: vect_is_simple_use: operand i_33
test.c:30: note: def_stmt: i_33 = i_63 + 1;

test.c:30: note: type of def: 3.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: vect_is_simple_use: operand img_start_indx_21(D)
test.c:30: note: def_stmt: GIMPLE_NOP

test.c:30: note: worklist: examine stmt: i_33 = i_63 + 1;

test.c:30: note: vect_is_simple_use: operand i_63
test.c:30: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: type of def: 4.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: already marked relevant/live.
test.c:30: note: === vect_analyze_dependences ===
test.c:30: note: === vect_determine_vectorization_factor ===
test.c:30: note: ==> examining phi: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 4 units of type int
test.c:30: note: vectype: vector(4) int
test.c:30: note: vectype: vector(4) int
test.c:30: note: nunits = 4
test.c:30: note: ==> examining phi: .MEM_54 = PHI <.MEM_60(9), .MEM_59(17)>

test.c:30: note: ==> examining statement: pretmp.44_110 = i_63 * 4096;

test.c:30: note: skip.
test.c:30: note: ==> examining phi: j_69 = PHI <j_32(6), 0(18)>

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 4 units of type int
test.c:30: note: vectype: vector(4) int
test.c:30: note: vectype: vector(4) int
test.c:30: note: nunits = 4
test.c:30: note: ==> examining phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:30: note: ==> examining phi: ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:30: note: ==> examining statement: D.7160_26 = j_69 + pretmp.44_110;

test.c:30: note: skip.
test.c:30: note: ==> examining statement: D.7161_27 = (unsigned int) D.7160_26;

test.c:30: note: skip.
test.c:30: note: ==> examining statement: D.7162_28 = D.7161_27 * 4;

test.c:30: note: skip.
test.c:30: note: ==> examining statement: D.7163_29 = image_11 + D.7162_28;

test.c:30: note: skip.
test.c:30: note: ==> examining statement: D.7164_30 = i_63 * j_69;

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 4 units of type int
test.c:30: note: vectype: vector(4) int
test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 4 units of type int
test.c:30: note: vectype: vector(4) int
test.c:30: note: vectype: vector(4) int
test.c:30: note: nunits = 4
test.c:30: note: ==> examining statement: D.7165_31 = D.7164_30 % 255;

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 4 units of type int
test.c:30: note: vectype: vector(4) int
test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 4 units of type int
test.c:30: note: vectype: vector(4) int
test.c:30: note: vectype: vector(4) int
test.c:30: note: nunits = 4
test.c:30: note: ==> examining statement: *D.7163_29 = D.7165_31;

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 4 units of type int
test.c:30: note: vectype: vector(4) int
test.c:30: note: vectype: vector(4) int
test.c:30: note: nunits = 4
test.c:30: note: ==> examining statement: j_32 = j_69 + 1;

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 4 units of type int
test.c:30: note: vectype: vector(4) int
test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 4 units of type int
test.c:30: note: vectype: vector(4) int
test.c:30: note: vectype: vector(4) int
test.c:30: note: nunits = 4
test.c:30: note: ==> examining statement: ivtmp.46_113 = ivtmp.46_115 - 1;

test.c:30: note: skip.
test.c:30: note: ==> examining statement: if (ivtmp.46_113 != 0)

test.c:30: note: skip.
test.c:30: note: ==> examining statement: i_33 = i_63 + 1;

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 4 units of type int
test.c:30: note: vectype: vector(4) int
test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 4 units of type int
test.c:30: note: vectype: vector(4) int
test.c:30: note: vectype: vector(4) int
test.c:30: note: nunits = 4
test.c:30: note: ==> examining statement: if (img_end_indx_23(D) > i_33)

test.c:30: note: skip.
test.c:30: note: vectorization factor = 4
test.c:30: note: === vect_analyze_data_refs_alignment ===
test.c:30: note: vect_compute_data_ref_alignment:
test.c:30: note: inner step doesn't divide the vector-size.
test.c:30: note: Unknown alignment for access: *((int * restrict) D.7152_10 + (unsigned int) ((unsigned int) i_63 * 16384))
test.c:30: note: === vect_analyze_data_ref_accesses ===
test.c:30: note: strided access in outer loop.
test.c:30: note: not vectorized: complicated access pattern.
test.c:30: note: bad data access.
test.c:30: note: ***** Re-trying analysis with vector size 8

test.c:30: note: === vect_analyze_loop_form ===
test.c:30: note: ===== analyze_loop_nest_1 =====
test.c:30: note: === vect_analyze_loop_form ===
test.c:30: note: === get_loop_niters ===
test.c:30: note: ==> get_loop_niters:4096
test.c:30: note: Considering outer-loop vectorization.
test.c:30: note: === get_loop_niters ===
test.c:30: note: ==> get_loop_niters:((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:30: note: Symbolic number of iterations is ((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:30: note: === vect_analyze_data_refs ===

test.c:30: note: analyze in outer-loop: *((int * restrict) D.7152_10 + (unsigned int) ((unsigned int) i_63 * 16384))
test.c:30: note: 	outer base_address: (int *) D.7152_10 + (unsigned int) ((unsigned int) img_start_indx_21(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:30: note: get vectype with 2 units of type int
test.c:30: note: vectype: vector(2) int
test.c:30: note: === vect_analyze_scalar_cycles ===
test.c:30: note: Analyze phi: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: Access function of PHI: {img_start_indx_21(D), +, 1}_2
test.c:30: note: step: 1,  init: img_start_indx_21(D)
test.c:30: note: Detected induction.
test.c:30: note: Analyze phi: .MEM_54 = PHI <.MEM_60(9), .MEM_59(17)>

test.c:30: note: === vect_analyze_scalar_cycles ===
test.c:30: note: Analyze phi: j_69 = PHI <j_32(6), 0(18)>

test.c:30: note: Access function of PHI: {0, +, 1}_3
test.c:30: note: step: 1,  init: 0
test.c:30: note: Detected induction.
test.c:30: note: Analyze phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:30: note: Analyze phi: ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:30: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:30: note: step: 4294967295,  init: 4096
test.c:30: note: Detected induction.
test.c:30: note: === vect_pattern_recog ===
test.c:30: note: vect_is_simple_use: operand i_63
test.c:30: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: type of def: 4.
test.c:30: note: vect_is_simple_use: operand D.7161_27
test.c:30: note: def_stmt: D.7161_27 = (unsigned int) D.7160_26;

test.c:30: note: type of def: 3.
test.c:30: note: vect_is_simple_use: operand i_63
test.c:30: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: type of def: 4.
test.c:30: note: === vect_mark_stmts_to_be_vectorized ===
test.c:30: note: init: phi relevant? i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: init: phi relevant? .MEM_54 = PHI <.MEM_60(9), .MEM_59(17)>

test.c:30: note: init: stmt relevant? pretmp.44_110 = i_63 * 4096;

test.c:30: note: init: phi relevant? j_69 = PHI <j_32(6), 0(18)>

test.c:30: note: init: phi relevant? .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:30: note: init: phi relevant? ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:30: note: init: stmt relevant? D.7160_26 = j_69 + pretmp.44_110;

test.c:30: note: init: stmt relevant? D.7161_27 = (unsigned int) D.7160_26;

test.c:30: note: init: stmt relevant? D.7162_28 = D.7161_27 * 4;

test.c:30: note: init: stmt relevant? D.7163_29 = image_11 + D.7162_28;

test.c:30: note: init: stmt relevant? D.7164_30 = i_63 * j_69;

test.c:30: note: init: stmt relevant? D.7165_31 = D.7164_30 % 255;

test.c:30: note: init: stmt relevant? *D.7163_29 = D.7165_31;

test.c:30: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: init: stmt relevant? j_32 = j_69 + 1;

test.c:30: note: init: stmt relevant? ivtmp.46_113 = ivtmp.46_115 - 1;

test.c:30: note: init: stmt relevant? if (ivtmp.46_113 != 0)

test.c:30: note: init: stmt relevant? i_33 = i_63 + 1;

test.c:30: note: init: stmt relevant? if (img_end_indx_23(D) > i_33)

test.c:30: note: worklist: examine stmt: *D.7163_29 = D.7165_31;

test.c:30: note: vect_is_simple_use: operand D.7165_31
test.c:30: note: def_stmt: D.7165_31 = D.7164_30 % 255;

test.c:30: note: type of def: 3.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: worklist: examine stmt: D.7165_31 = D.7164_30 % 255;

test.c:30: note: vect_is_simple_use: operand D.7164_30
test.c:30: note: def_stmt: D.7164_30 = i_63 * j_69;

test.c:30: note: type of def: 3.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: worklist: examine stmt: D.7164_30 = i_63 * j_69;

test.c:30: note: vect_is_simple_use: operand i_63
test.c:30: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: type of def: 4.
test.c:30: note: outer-loop def-stmt defining inner-loop stmt.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: vect_is_simple_use: operand j_69
test.c:30: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:30: note: type of def: 4.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: worklist: examine stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:30: note: vect_is_simple_use: operand j_32
test.c:30: note: def_stmt: j_32 = j_69 + 1;

test.c:30: note: type of def: 3.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: vect_is_simple_use: operand 0
test.c:30: note: worklist: examine stmt: j_32 = j_69 + 1;

test.c:30: note: vect_is_simple_use: operand j_69
test.c:30: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:30: note: type of def: 4.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: already marked relevant/live.
test.c:30: note: worklist: examine stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: vect_is_simple_use: operand i_33
test.c:30: note: def_stmt: i_33 = i_63 + 1;

test.c:30: note: type of def: 3.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: vect_is_simple_use: operand img_start_indx_21(D)
test.c:30: note: def_stmt: GIMPLE_NOP

test.c:30: note: worklist: examine stmt: i_33 = i_63 + 1;

test.c:30: note: vect_is_simple_use: operand i_63
test.c:30: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: type of def: 4.
test.c:30: note: mark relevant 4, live 0.
test.c:30: note: already marked relevant/live.
test.c:30: note: === vect_analyze_dependences ===
test.c:30: note: === vect_determine_vectorization_factor ===
test.c:30: note: ==> examining phi: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 2 units of type int
test.c:30: note: vectype: vector(2) int
test.c:30: note: vectype: vector(2) int
test.c:30: note: nunits = 2
test.c:30: note: ==> examining phi: .MEM_54 = PHI <.MEM_60(9), .MEM_59(17)>

test.c:30: note: ==> examining statement: pretmp.44_110 = i_63 * 4096;

test.c:30: note: skip.
test.c:30: note: ==> examining phi: j_69 = PHI <j_32(6), 0(18)>

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 2 units of type int
test.c:30: note: vectype: vector(2) int
test.c:30: note: vectype: vector(2) int
test.c:30: note: nunits = 2
test.c:30: note: ==> examining phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:30: note: ==> examining phi: ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:30: note: ==> examining statement: D.7160_26 = j_69 + pretmp.44_110;

test.c:30: note: skip.
test.c:30: note: ==> examining statement: D.7161_27 = (unsigned int) D.7160_26;

test.c:30: note: skip.
test.c:30: note: ==> examining statement: D.7162_28 = D.7161_27 * 4;

test.c:30: note: skip.
test.c:30: note: ==> examining statement: D.7163_29 = image_11 + D.7162_28;

test.c:30: note: skip.
test.c:30: note: ==> examining statement: D.7164_30 = i_63 * j_69;

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 2 units of type int
test.c:30: note: vectype: vector(2) int
test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 2 units of type int
test.c:30: note: vectype: vector(2) int
test.c:30: note: vectype: vector(2) int
test.c:30: note: nunits = 2
test.c:30: note: ==> examining statement: D.7165_31 = D.7164_30 % 255;

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 2 units of type int
test.c:30: note: vectype: vector(2) int
test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 2 units of type int
test.c:30: note: vectype: vector(2) int
test.c:30: note: vectype: vector(2) int
test.c:30: note: nunits = 2
test.c:30: note: ==> examining statement: *D.7163_29 = D.7165_31;

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 2 units of type int
test.c:30: note: vectype: vector(2) int
test.c:30: note: vectype: vector(2) int
test.c:30: note: nunits = 2
test.c:30: note: ==> examining statement: j_32 = j_69 + 1;

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 2 units of type int
test.c:30: note: vectype: vector(2) int
test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 2 units of type int
test.c:30: note: vectype: vector(2) int
test.c:30: note: vectype: vector(2) int
test.c:30: note: nunits = 2
test.c:30: note: ==> examining statement: ivtmp.46_113 = ivtmp.46_115 - 1;

test.c:30: note: skip.
test.c:30: note: ==> examining statement: if (ivtmp.46_113 != 0)

test.c:30: note: skip.
test.c:30: note: ==> examining statement: i_33 = i_63 + 1;

test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 2 units of type int
test.c:30: note: vectype: vector(2) int
test.c:30: note: get vectype for scalar type:  int
test.c:30: note: get vectype with 2 units of type int
test.c:30: note: vectype: vector(2) int
test.c:30: note: vectype: vector(2) int
test.c:30: note: nunits = 2
test.c:30: note: ==> examining statement: if (img_end_indx_23(D) > i_33)

test.c:30: note: skip.
test.c:30: note: vectorization factor = 2
test.c:30: note: === vect_analyze_data_refs_alignment ===
test.c:30: note: vect_compute_data_ref_alignment:
test.c:30: note: inner step doesn't divide the vector-size.
test.c:30: note: Unknown alignment for access: *((int * restrict) D.7152_10 + (unsigned int) ((unsigned int) i_63 * 16384))
test.c:30: note: === vect_analyze_data_ref_accesses ===
test.c:30: note: strided access in outer loop.
test.c:30: note: not vectorized: complicated access pattern.
test.c:30: note: bad data access.
test.c:31: note: ===== analyze_loop_nest =====
test.c:31: note: === vect_analyze_loop_form ===
test.c:31: note: === get_loop_niters ===
test.c:31: note: ==> get_loop_niters:4096
test.c:31: note: === vect_analyze_data_refs ===

test.c:31: note: get vectype with 4 units of type int
test.c:31: note: vectype: vector(4) int
test.c:31: note: === vect_analyze_scalar_cycles ===
test.c:31: note: Analyze phi: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: Access function of PHI: {0, +, 1}_3
test.c:31: note: step: 1,  init: 0
test.c:31: note: Detected induction.
test.c:31: note: Analyze phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:31: note: Analyze phi: ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:31: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:31: note: step: 4294967295,  init: 4096
test.c:31: note: Detected induction.
test.c:31: note: === vect_pattern_recog ===
test.c:31: note: vect_is_simple_use: operand D.7161_27
test.c:31: note: def_stmt: D.7161_27 = (unsigned int) D.7160_26;

test.c:31: note: type of def: 3.
test.c:31: note: vect_is_simple_use: operand i_63
test.c:31: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:31: note: type of def: 2.
test.c:31: note: === vect_mark_stmts_to_be_vectorized ===
test.c:31: note: init: phi relevant? j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: init: phi relevant? .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:31: note: init: phi relevant? ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:31: note: init: stmt relevant? D.7160_26 = j_69 + pretmp.44_110;

test.c:31: note: init: stmt relevant? D.7161_27 = (unsigned int) D.7160_26;

test.c:31: note: init: stmt relevant? D.7162_28 = D.7161_27 * 4;

test.c:31: note: init: stmt relevant? D.7163_29 = image_11 + D.7162_28;

test.c:31: note: init: stmt relevant? D.7164_30 = i_63 * j_69;

test.c:31: note: init: stmt relevant? D.7165_31 = D.7164_30 % 255;

test.c:31: note: init: stmt relevant? *D.7163_29 = D.7165_31;

test.c:31: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:31: note: mark relevant 4, live 0.
test.c:31: note: init: stmt relevant? j_32 = j_69 + 1;

test.c:31: note: init: stmt relevant? ivtmp.46_113 = ivtmp.46_115 - 1;

test.c:31: note: init: stmt relevant? if (ivtmp.46_113 != 0)

test.c:31: note: worklist: examine stmt: *D.7163_29 = D.7165_31;

test.c:31: note: vect_is_simple_use: operand D.7165_31
test.c:31: note: def_stmt: D.7165_31 = D.7164_30 % 255;

test.c:31: note: type of def: 3.
test.c:31: note: mark relevant 4, live 0.
test.c:31: note: worklist: examine stmt: D.7165_31 = D.7164_30 % 255;

test.c:31: note: vect_is_simple_use: operand D.7164_30
test.c:31: note: def_stmt: D.7164_30 = i_63 * j_69;

test.c:31: note: type of def: 3.
test.c:31: note: mark relevant 4, live 0.
test.c:31: note: worklist: examine stmt: D.7164_30 = i_63 * j_69;

test.c:31: note: vect_is_simple_use: operand i_63
test.c:31: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:31: note: type of def: 2.
test.c:31: note: def_stmt is out of loop.
test.c:31: note: vect_is_simple_use: operand j_69
test.c:31: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: type of def: 4.
test.c:31: note: mark relevant 4, live 0.
test.c:31: note: worklist: examine stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: vect_is_simple_use: operand j_32
test.c:31: note: def_stmt: j_32 = j_69 + 1;

test.c:31: note: type of def: 3.
test.c:31: note: mark relevant 4, live 0.
test.c:31: note: vect_is_simple_use: operand 0
test.c:31: note: worklist: examine stmt: j_32 = j_69 + 1;

test.c:31: note: vect_is_simple_use: operand j_69
test.c:31: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: type of def: 4.
test.c:31: note: mark relevant 4, live 0.
test.c:31: note: already marked relevant/live.
test.c:31: note: === vect_analyze_dependences ===
test.c:31: note: === vect_determine_vectorization_factor ===
test.c:31: note: ==> examining phi: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 4 units of type int
test.c:31: note: vectype: vector(4) int
test.c:31: note: vectype: vector(4) int
test.c:31: note: nunits = 4
test.c:31: note: ==> examining phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:31: note: ==> examining phi: ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:31: note: ==> examining statement: D.7160_26 = j_69 + pretmp.44_110;

test.c:31: note: skip.
test.c:31: note: ==> examining statement: D.7161_27 = (unsigned int) D.7160_26;

test.c:31: note: skip.
test.c:31: note: ==> examining statement: D.7162_28 = D.7161_27 * 4;

test.c:31: note: skip.
test.c:31: note: ==> examining statement: D.7163_29 = image_11 + D.7162_28;

test.c:31: note: skip.
test.c:31: note: ==> examining statement: D.7164_30 = i_63 * j_69;

test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 4 units of type int
test.c:31: note: vectype: vector(4) int
test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 4 units of type int
test.c:31: note: vectype: vector(4) int
test.c:31: note: vectype: vector(4) int
test.c:31: note: nunits = 4
test.c:31: note: ==> examining statement: D.7165_31 = D.7164_30 % 255;

test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 4 units of type int
test.c:31: note: vectype: vector(4) int
test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 4 units of type int
test.c:31: note: vectype: vector(4) int
test.c:31: note: vectype: vector(4) int
test.c:31: note: nunits = 4
test.c:31: note: ==> examining statement: *D.7163_29 = D.7165_31;

test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 4 units of type int
test.c:31: note: vectype: vector(4) int
test.c:31: note: vectype: vector(4) int
test.c:31: note: nunits = 4
test.c:31: note: ==> examining statement: j_32 = j_69 + 1;

test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 4 units of type int
test.c:31: note: vectype: vector(4) int
test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 4 units of type int
test.c:31: note: vectype: vector(4) int
test.c:31: note: vectype: vector(4) int
test.c:31: note: nunits = 4
test.c:31: note: ==> examining statement: ivtmp.46_113 = ivtmp.46_115 - 1;

test.c:31: note: skip.
test.c:31: note: ==> examining statement: if (ivtmp.46_113 != 0)

test.c:31: note: skip.
test.c:31: note: vectorization factor = 4
test.c:31: note: === vect_analyze_data_refs_alignment ===
test.c:31: note: vect_compute_data_ref_alignment:
test.c:31: note: can't force alignment of ref: *D.7163_29
test.c:31: note: === vect_analyze_data_ref_accesses ===
test.c:31: note: === vect_prune_runtime_alias_test_list ===
test.c:31: note: === vect_enhance_data_refs_alignment ===
test.c:31: note: Unknown misalignment, is_packed = 0
test.c:31: note: vect_can_advance_ivs_p:
test.c:31: note: Analyze phi: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: Access function of PHI: {0, +, 1}_3
test.c:31: note: Analyze phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:31: note: virtual phi. skip.
test.c:31: note: Analyze phi: ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:31: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:31: note: Alignment of access forced using peeling.
test.c:31: note: Peeling for alignment will be applied.
test.c:31: note: === vect_analyze_slp ===
test.c:31: note: === vect_make_slp_decision ===
test.c:31: note: === vect_detect_hybrid_slp ===
test.c:31: note: === vect_analyze_loop_operations ===
test.c:31: note: examining phi: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: === vectorizable_induction ===
test.c:31: note: vect_model_induction_cost: inside_cost = 1, outside_cost = 2 .
test.c:31: note: examining phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:31: note: examining phi: ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:31: note: ==> examining statement: D.7160_26 = j_69 + pretmp.44_110;

test.c:31: note: irrelevant.
test.c:31: note: ==> examining statement: D.7161_27 = (unsigned int) D.7160_26;

test.c:31: note: irrelevant.
test.c:31: note: ==> examining statement: D.7162_28 = D.7161_27 * 4;

test.c:31: note: irrelevant.
test.c:31: note: ==> examining statement: D.7163_29 = image_11 + D.7162_28;

test.c:31: note: irrelevant.
test.c:31: note: ==> examining statement: D.7164_30 = i_63 * j_69;

test.c:31: note: vect_is_simple_use: operand i_63
test.c:31: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:31: note: type of def: 2.
test.c:31: note: get vectype with 4 units of type int
test.c:31: note: vectype: vector(4) int
test.c:31: note: vect_is_simple_use: operand j_69
test.c:31: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: type of def: 4.
test.c:31: note: === vectorizable_operation ===
test.c:31: note: vect_model_simple_cost: inside_cost = 1, outside_cost = 1 .
test.c:31: note: ==> examining statement: D.7165_31 = D.7164_30 % 255;

test.c:31: note: vect_is_simple_use: operand D.7164_30
test.c:31: note: def_stmt: D.7164_30 = i_63 * j_69;

test.c:31: note: type of def: 3.
test.c:31: note: vect_is_simple_use: operand 255
test.c:31: note: op not supported by target.
test.c:31: note: not vectorized: relevant stmt not supported: D.7165_31 = D.7164_30 % 255;

test.c:31: note: bad operation or unsupported loop bound.
test.c:31: note: ***** Re-trying analysis with vector size 8

test.c:31: note: === vect_analyze_loop_form ===
test.c:31: note: === get_loop_niters ===
test.c:31: note: ==> get_loop_niters:4096
test.c:31: note: === vect_analyze_data_refs ===

test.c:31: note: get vectype with 2 units of type int
test.c:31: note: vectype: vector(2) int
test.c:31: note: === vect_analyze_scalar_cycles ===
test.c:31: note: Analyze phi: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: Access function of PHI: {0, +, 1}_3
test.c:31: note: step: 1,  init: 0
test.c:31: note: Detected induction.
test.c:31: note: Analyze phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:31: note: Analyze phi: ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:31: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:31: note: step: 4294967295,  init: 4096
test.c:31: note: Detected induction.
test.c:31: note: === vect_pattern_recog ===
test.c:31: note: vect_is_simple_use: operand D.7161_27
test.c:31: note: def_stmt: D.7161_27 = (unsigned int) D.7160_26;

test.c:31: note: type of def: 3.
test.c:31: note: vect_is_simple_use: operand i_63
test.c:31: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:31: note: type of def: 2.
test.c:31: note: === vect_mark_stmts_to_be_vectorized ===
test.c:31: note: init: phi relevant? j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: init: phi relevant? .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:31: note: init: phi relevant? ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:31: note: init: stmt relevant? D.7160_26 = j_69 + pretmp.44_110;

test.c:31: note: init: stmt relevant? D.7161_27 = (unsigned int) D.7160_26;

test.c:31: note: init: stmt relevant? D.7162_28 = D.7161_27 * 4;

test.c:31: note: init: stmt relevant? D.7163_29 = image_11 + D.7162_28;

test.c:31: note: init: stmt relevant? D.7164_30 = i_63 * j_69;

test.c:31: note: init: stmt relevant? D.7165_31 = D.7164_30 % 255;

test.c:31: note: init: stmt relevant? *D.7163_29 = D.7165_31;

test.c:31: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:31: note: mark relevant 4, live 0.
test.c:31: note: init: stmt relevant? j_32 = j_69 + 1;

test.c:31: note: init: stmt relevant? ivtmp.46_113 = ivtmp.46_115 - 1;

test.c:31: note: init: stmt relevant? if (ivtmp.46_113 != 0)

test.c:31: note: worklist: examine stmt: *D.7163_29 = D.7165_31;

test.c:31: note: vect_is_simple_use: operand D.7165_31
test.c:31: note: def_stmt: D.7165_31 = D.7164_30 % 255;

test.c:31: note: type of def: 3.
test.c:31: note: mark relevant 4, live 0.
test.c:31: note: worklist: examine stmt: D.7165_31 = D.7164_30 % 255;

test.c:31: note: vect_is_simple_use: operand D.7164_30
test.c:31: note: def_stmt: D.7164_30 = i_63 * j_69;

test.c:31: note: type of def: 3.
test.c:31: note: mark relevant 4, live 0.
test.c:31: note: worklist: examine stmt: D.7164_30 = i_63 * j_69;

test.c:31: note: vect_is_simple_use: operand i_63
test.c:31: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:31: note: type of def: 2.
test.c:31: note: def_stmt is out of loop.
test.c:31: note: vect_is_simple_use: operand j_69
test.c:31: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: type of def: 4.
test.c:31: note: mark relevant 4, live 0.
test.c:31: note: worklist: examine stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: vect_is_simple_use: operand j_32
test.c:31: note: def_stmt: j_32 = j_69 + 1;

test.c:31: note: type of def: 3.
test.c:31: note: mark relevant 4, live 0.
test.c:31: note: vect_is_simple_use: operand 0
test.c:31: note: worklist: examine stmt: j_32 = j_69 + 1;

test.c:31: note: vect_is_simple_use: operand j_69
test.c:31: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: type of def: 4.
test.c:31: note: mark relevant 4, live 0.
test.c:31: note: already marked relevant/live.
test.c:31: note: === vect_analyze_dependences ===
test.c:31: note: === vect_determine_vectorization_factor ===
test.c:31: note: ==> examining phi: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 2 units of type int
test.c:31: note: vectype: vector(2) int
test.c:31: note: vectype: vector(2) int
test.c:31: note: nunits = 2
test.c:31: note: ==> examining phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:31: note: ==> examining phi: ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:31: note: ==> examining statement: D.7160_26 = j_69 + pretmp.44_110;

test.c:31: note: skip.
test.c:31: note: ==> examining statement: D.7161_27 = (unsigned int) D.7160_26;

test.c:31: note: skip.
test.c:31: note: ==> examining statement: D.7162_28 = D.7161_27 * 4;

test.c:31: note: skip.
test.c:31: note: ==> examining statement: D.7163_29 = image_11 + D.7162_28;

test.c:31: note: skip.
test.c:31: note: ==> examining statement: D.7164_30 = i_63 * j_69;

test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 2 units of type int
test.c:31: note: vectype: vector(2) int
test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 2 units of type int
test.c:31: note: vectype: vector(2) int
test.c:31: note: vectype: vector(2) int
test.c:31: note: nunits = 2
test.c:31: note: ==> examining statement: D.7165_31 = D.7164_30 % 255;

test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 2 units of type int
test.c:31: note: vectype: vector(2) int
test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 2 units of type int
test.c:31: note: vectype: vector(2) int
test.c:31: note: vectype: vector(2) int
test.c:31: note: nunits = 2
test.c:31: note: ==> examining statement: *D.7163_29 = D.7165_31;

test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 2 units of type int
test.c:31: note: vectype: vector(2) int
test.c:31: note: vectype: vector(2) int
test.c:31: note: nunits = 2
test.c:31: note: ==> examining statement: j_32 = j_69 + 1;

test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 2 units of type int
test.c:31: note: vectype: vector(2) int
test.c:31: note: get vectype for scalar type:  int
test.c:31: note: get vectype with 2 units of type int
test.c:31: note: vectype: vector(2) int
test.c:31: note: vectype: vector(2) int
test.c:31: note: nunits = 2
test.c:31: note: ==> examining statement: ivtmp.46_113 = ivtmp.46_115 - 1;

test.c:31: note: skip.
test.c:31: note: ==> examining statement: if (ivtmp.46_113 != 0)

test.c:31: note: skip.
test.c:31: note: vectorization factor = 2
test.c:31: note: === vect_analyze_data_refs_alignment ===
test.c:31: note: vect_compute_data_ref_alignment:
test.c:31: note: can't force alignment of ref: *D.7163_29
test.c:31: note: === vect_analyze_data_ref_accesses ===
test.c:31: note: === vect_prune_runtime_alias_test_list ===
test.c:31: note: === vect_enhance_data_refs_alignment ===
test.c:31: note: Unknown misalignment, is_packed = 0
test.c:31: note: vect_can_advance_ivs_p:
test.c:31: note: Analyze phi: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: Access function of PHI: {0, +, 1}_3
test.c:31: note: Analyze phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:31: note: virtual phi. skip.
test.c:31: note: Analyze phi: ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:31: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:31: note: Alignment of access forced using peeling.
test.c:31: note: Peeling for alignment will be applied.
test.c:31: note: === vect_analyze_slp ===
test.c:31: note: === vect_make_slp_decision ===
test.c:31: note: === vect_detect_hybrid_slp ===
test.c:31: note: === vect_analyze_loop_operations ===
test.c:31: note: examining phi: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: === vectorizable_induction ===
test.c:31: note: vect_model_induction_cost: inside_cost = 1, outside_cost = 2 .
test.c:31: note: examining phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:31: note: examining phi: ivtmp.46_115 = PHI <ivtmp.46_113(6), 4096(18)>

test.c:31: note: ==> examining statement: D.7160_26 = j_69 + pretmp.44_110;

test.c:31: note: irrelevant.
test.c:31: note: ==> examining statement: D.7161_27 = (unsigned int) D.7160_26;

test.c:31: note: irrelevant.
test.c:31: note: ==> examining statement: D.7162_28 = D.7161_27 * 4;

test.c:31: note: irrelevant.
test.c:31: note: ==> examining statement: D.7163_29 = image_11 + D.7162_28;

test.c:31: note: irrelevant.
test.c:31: note: ==> examining statement: D.7164_30 = i_63 * j_69;

test.c:31: note: vect_is_simple_use: operand i_63
test.c:31: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:31: note: type of def: 2.
test.c:31: note: get vectype with 2 units of type int
test.c:31: note: vectype: vector(2) int
test.c:31: note: vect_is_simple_use: operand j_69
test.c:31: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:31: note: type of def: 4.
test.c:31: note: === vectorizable_operation ===
test.c:31: note: vect_model_simple_cost: inside_cost = 1, outside_cost = 1 .
test.c:31: note: ==> examining statement: D.7165_31 = D.7164_30 % 255;

test.c:31: note: vect_is_simple_use: operand D.7164_30
test.c:31: note: def_stmt: D.7164_30 = i_63 * j_69;

test.c:31: note: type of def: 3.
test.c:31: note: vect_is_simple_use: operand 255
test.c:31: note: op not supported by target.
test.c:31: note: not vectorized: relevant stmt not supported: D.7165_31 = D.7164_30 % 255;

test.c:31: note: bad operation or unsupported loop bound.
test.c:26: note: ===== analyze_loop_nest =====
test.c:26: note: === vect_analyze_loop_form ===
test.c:26: note: === get_loop_niters ===
test.c:26: note: ==> get_loop_niters:256
test.c:26: note: === vect_analyze_data_refs ===

test.c:26: note: get vectype with 4 units of type int
test.c:26: note: vectype: vector(4) int
test.c:26: note: === vect_analyze_scalar_cycles ===
test.c:26: note: Analyze phi: i_64 = PHI <i_20(4), 0(2)>

test.c:26: note: Access function of PHI: {0, +, 1}_1
test.c:26: note: step: 1,  init: 0
test.c:26: note: Detected induction.
test.c:26: note: Analyze phi: .MEM_73 = PHI <.MEM_59(4), .MEM_58(D)(2)>

test.c:26: note: Analyze phi: ivtmp.47_112 = PHI <ivtmp.47_111(4), 256(2)>

test.c:26: note: Access function of PHI: {256, +, 4294967295}_1
test.c:26: note: step: 4294967295,  init: 256
test.c:26: note: Detected induction.
test.c:26: note: === vect_pattern_recog ===
test.c:26: note: vect_is_simple_use: operand i.8_17
test.c:26: note: def_stmt: i.8_17 = (unsigned int) i_64;

test.c:26: note: type of def: 3.
test.c:26: note: === vect_mark_stmts_to_be_vectorized ===
test.c:26: note: init: phi relevant? i_64 = PHI <i_20(4), 0(2)>

test.c:26: note: init: phi relevant? .MEM_73 = PHI <.MEM_59(4), .MEM_58(D)(2)>

test.c:26: note: init: phi relevant? ivtmp.47_112 = PHI <ivtmp.47_111(4), 256(2)>

test.c:26: note: init: stmt relevant? i.8_17 = (unsigned int) i_64;

test.c:26: note: init: stmt relevant? D.7157_18 = i.8_17 * 4;

test.c:26: note: init: stmt relevant? D.7158_19 = histogram_15 + D.7157_18;

test.c:26: note: init: stmt relevant? *D.7158_19 = 0;

test.c:26: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:26: note: mark relevant 4, live 0.
test.c:26: note: init: stmt relevant? i_20 = i_64 + 1;

test.c:26: note: init: stmt relevant? ivtmp.47_111 = ivtmp.47_112 - 1;

test.c:26: note: init: stmt relevant? if (ivtmp.47_111 != 0)

test.c:26: note: worklist: examine stmt: *D.7158_19 = 0;

test.c:26: note: === vect_analyze_dependences ===
test.c:26: note: === vect_determine_vectorization_factor ===
test.c:26: note: ==> examining phi: i_64 = PHI <i_20(4), 0(2)>

test.c:26: note: ==> examining phi: .MEM_73 = PHI <.MEM_59(4), .MEM_58(D)(2)>

test.c:26: note: ==> examining phi: ivtmp.47_112 = PHI <ivtmp.47_111(4), 256(2)>

test.c:26: note: ==> examining statement: i.8_17 = (unsigned int) i_64;

test.c:26: note: skip.
test.c:26: note: ==> examining statement: D.7157_18 = i.8_17 * 4;

test.c:26: note: skip.
test.c:26: note: ==> examining statement: D.7158_19 = histogram_15 + D.7157_18;

test.c:26: note: skip.
test.c:26: note: ==> examining statement: *D.7158_19 = 0;

test.c:26: note: get vectype for scalar type:  int
test.c:26: note: get vectype with 4 units of type int
test.c:26: note: vectype: vector(4) int
test.c:26: note: vectype: vector(4) int
test.c:26: note: nunits = 4
test.c:26: note: ==> examining statement: i_20 = i_64 + 1;

test.c:26: note: skip.
test.c:26: note: ==> examining statement: ivtmp.47_111 = ivtmp.47_112 - 1;

test.c:26: note: skip.
test.c:26: note: ==> examining statement: if (ivtmp.47_111 != 0)

test.c:26: note: skip.
test.c:26: note: vectorization factor = 4
test.c:26: note: === vect_analyze_data_refs_alignment ===
test.c:26: note: vect_compute_data_ref_alignment:
test.c:26: note: can't force alignment of ref: *D.7158_19
test.c:26: note: === vect_analyze_data_ref_accesses ===
test.c:26: note: === vect_prune_runtime_alias_test_list ===
test.c:26: note: === vect_enhance_data_refs_alignment ===
test.c:26: note: Unknown misalignment, is_packed = 0
test.c:26: note: vect_can_advance_ivs_p:
test.c:26: note: Analyze phi: i_64 = PHI <i_20(4), 0(2)>

test.c:26: note: Access function of PHI: {0, +, 1}_1
test.c:26: note: Analyze phi: .MEM_73 = PHI <.MEM_59(4), .MEM_58(D)(2)>

test.c:26: note: virtual phi. skip.
test.c:26: note: Analyze phi: ivtmp.47_112 = PHI <ivtmp.47_111(4), 256(2)>

test.c:26: note: Access function of PHI: {256, +, 4294967295}_1
test.c:26: note: Alignment of access forced using peeling.
test.c:26: note: Peeling for alignment will be applied.
test.c:26: note: === vect_analyze_slp ===
test.c:26: note: === vect_make_slp_decision ===
test.c:26: note: === vect_detect_hybrid_slp ===
test.c:26: note: === vect_analyze_loop_operations ===
test.c:26: note: examining phi: i_64 = PHI <i_20(4), 0(2)>

test.c:26: note: examining phi: .MEM_73 = PHI <.MEM_59(4), .MEM_58(D)(2)>

test.c:26: note: examining phi: ivtmp.47_112 = PHI <ivtmp.47_111(4), 256(2)>

test.c:26: note: ==> examining statement: i.8_17 = (unsigned int) i_64;

test.c:26: note: irrelevant.
test.c:26: note: ==> examining statement: D.7157_18 = i.8_17 * 4;

test.c:26: note: irrelevant.
test.c:26: note: ==> examining statement: D.7158_19 = histogram_15 + D.7157_18;

test.c:26: note: irrelevant.
test.c:26: note: ==> examining statement: *D.7158_19 = 0;

test.c:26: note: vect_is_simple_use: operand 0
test.c:26: note: vect_model_store_cost: aligned.
test.c:26: note: vect_model_store_cost: inside_cost = 1, outside_cost = 1 .
test.c:26: note: ==> examining statement: i_20 = i_64 + 1;

test.c:26: note: irrelevant.
test.c:26: note: ==> examining statement: ivtmp.47_111 = ivtmp.47_112 - 1;

test.c:26: note: irrelevant.
test.c:26: note: ==> examining statement: if (ivtmp.47_111 != 0)

test.c:26: note: irrelevant.
test.c:26: note: vectorization_factor = 4, niters = 256
test.c:26: note: === vect_update_slp_costs_according_to_vf ===
test.c:26: note: cost model disabled.
test.c:26: note: epilog loop required.
test.c:26: note: vect_can_advance_ivs_p:
test.c:26: note: Analyze phi: i_64 = PHI <i_20(4), 0(2)>

test.c:26: note: Access function of PHI: {0, +, 1}_1
test.c:26: note: Analyze phi: .MEM_73 = PHI <.MEM_59(4), .MEM_58(D)(2)>

test.c:26: note: virtual phi. skip.
test.c:26: note: Analyze phi: ivtmp.47_112 = PHI <ivtmp.47_111(4), 256(2)>

test.c:26: note: Access function of PHI: {256, +, 4294967295}_1
test.c:26: note: === vec_transform_loop ===
test.c:26: note: === vect_do_peeling_for_alignment ===
test.c:26: note: created vect_p.51_109
test.c:26: note: niters for prolog loop: -(((unsigned int) vect_p.51_109 & 15) >> 2) & 3
test.c:26: note: Profitability threshold is 3 loop iterations.
test.c:26: note: === vect_update_inits_of_dr ===
test.c:26: note: === vect_do_peeling_for_loop_bound ===
test.c:26: note: vect_update_ivs_after_vectorizer: phi: i_64 = PHI <i_20(4), i_130(31)>

test.c:26: note: vect_update_ivs_after_vectorizer: phi: .MEM_73 = PHI <.MEM_59(4), .MEM_132(31)>

test.c:26: note: virtual phi. skip.
test.c:26: note: vect_update_ivs_after_vectorizer: phi: ivtmp.47_112 = PHI <ivtmp.47_111(4), ivtmp.47_133(31)>

test.c:26: note: ------>vectorizing phi: i_64 = PHI <i_20(4), i_130(36)>

test.c:26: note: ------>vectorizing phi: .MEM_73 = PHI <.MEM_59(4), .MEM_132(36)>

test.c:26: note: ------>vectorizing phi: ivtmp.47_112 = PHI <ivtmp.47_111(4), ivtmp.47_133(36)>

test.c:26: note: ------>vectorizing statement: i.8_17 = (unsigned int) i_64;

test.c:26: note: ------>vectorizing statement: D.7157_18 = i.8_17 * 4;

test.c:26: note: ------>vectorizing statement: D.7158_19 = histogram_15 + D.7157_18;

test.c:26: note: ------>vectorizing statement: *D.7158_19 = 0;

test.c:26: note: transform statement.
test.c:26: note: vect_is_simple_use: operand 0
test.c:26: note: transform store. ncopies = 1
test.c:26: note: vect_get_vec_def_for_operand: 0
test.c:26: note: vect_is_simple_use: operand 0
test.c:26: note: 
test.c:26: note: get vectype with 4 units of type int
test.c:26: note: vectype: vector(4) int
test.c:26: note: Create vector_cst. nunits = 4
test.c:26: note: created new init_stmt: vect_cst_.60_160 = { 0, 0, 0, 0 };

test.c:26: note: create vector_type-pointer variable to type: vector(4) int*D.7155_14
test.c:26: note: created vect_p.64_163
test.c:26: note: add new stmt: MEM[(int *)vect_p.61_164] = vect_cst_.60_160;

test.c:26: note: ------>vectorizing statement: i_20 = i_64 + 1;

test.c:26: note: ------>vectorizing statement: ivtmp.47_111 = ivtmp.47_112 - 1;

test.c:26: note: ------>vectorizing statement: vect_p.61_165 = vect_p.61_164 + 16;

test.c:26: note: ------>vectorizing statement: if (ivtmp.47_111 != 0)

test.c:26: note: LOOP VECTORIZED.
test.c:17: note: vectorized 1 loops in function.

test.c:67: note: ===== analyze_loop_nest =====
test.c:67: note: === vect_analyze_loop_form ===
test.c:67: note: ===== analyze_loop_nest_1 =====
test.c:67: note: === vect_analyze_loop_form ===
test.c:67: note: === get_loop_niters ===
test.c:67: note: ==> get_loop_niters:4096
test.c:67: note: Considering outer-loop vectorization.
test.c:67: note: split exit edge.
test.c:67: note: === get_loop_niters ===
test.c:67: note: ==> get_loop_niters:((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:67: note: Symbolic number of iterations is ((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:67: note: === vect_analyze_data_refs ===

test.c:67: note: analyze in outer-loop: *((int * restrict) D.7130_10 + (unsigned int) ((unsigned int) i_71 * 16384))
test.c:67: note: 	outer base_address: (int *) D.7130_10 + (unsigned int) ((unsigned int) img_start_indx_21(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:67: note: get vectype with 4 units of type int
test.c:67: note: vectype: vector(4) int
test.c:67: note: not vectorized: data ref analysis failed D.7147_48 = *D.7146_47;

test.c:67: note: bad data references.
test.c:67: note: ***** Re-trying analysis with vector size 8

test.c:67: note: === vect_analyze_loop_form ===
test.c:67: note: ===== analyze_loop_nest_1 =====
test.c:67: note: === vect_analyze_loop_form ===
test.c:67: note: === get_loop_niters ===
test.c:67: note: ==> get_loop_niters:4096
test.c:67: note: Considering outer-loop vectorization.
test.c:67: note: === get_loop_niters ===
test.c:67: note: ==> get_loop_niters:((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:67: note: Symbolic number of iterations is ((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:67: note: === vect_analyze_data_refs ===

test.c:67: note: analyze in outer-loop: *((int * restrict) D.7130_10 + (unsigned int) ((unsigned int) i_71 * 16384))
test.c:67: note: 	outer base_address: (int *) D.7130_10 + (unsigned int) ((unsigned int) img_start_indx_21(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:67: note: get vectype with 2 units of type int
test.c:67: note: vectype: vector(2) int
test.c:67: note: not vectorized: data ref analysis failed D.7147_48 = *D.7146_47;

test.c:67: note: bad data references.
test.c:68: note: ===== analyze_loop_nest =====
test.c:68: note: === vect_analyze_loop_form ===
test.c:68: note: === get_loop_niters ===
test.c:68: note: ==> get_loop_niters:4096
test.c:68: note: === vect_analyze_data_refs ===

test.c:68: note: get vectype with 4 units of type int
test.c:68: note: vectype: vector(4) int
test.c:68: note: not vectorized: data ref analysis failed D.7147_48 = *D.7146_47;

test.c:68: note: bad data references.
test.c:68: note: ***** Re-trying analysis with vector size 8

test.c:68: note: === vect_analyze_loop_form ===
test.c:68: note: === get_loop_niters ===
test.c:68: note: ==> get_loop_niters:4096
test.c:68: note: === vect_analyze_data_refs ===

test.c:68: note: get vectype with 2 units of type int
test.c:68: note: vectype: vector(2) int
test.c:68: note: not vectorized: data ref analysis failed D.7147_48 = *D.7146_47;

test.c:68: note: bad data references.
test.c:60: note: ===== analyze_loop_nest =====
test.c:60: note: === vect_analyze_loop_form ===
test.c:60: note: ===== analyze_loop_nest_1 =====
test.c:60: note: === vect_analyze_loop_form ===
test.c:60: note: === get_loop_niters ===
test.c:60: note: ==> get_loop_niters:4096
test.c:60: note: Considering outer-loop vectorization.
test.c:60: note: === get_loop_niters ===
test.c:60: note: ==> get_loop_niters:((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:60: note: Symbolic number of iterations is ((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:60: note: === vect_analyze_data_refs ===

test.c:60: note: analyze in outer-loop: *((int * restrict) D.7130_10 + (unsigned int) ((unsigned int) i_63 * 16384))
test.c:60: note: 	outer base_address: (int *) D.7130_10 + (unsigned int) ((unsigned int) img_start_indx_21(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:60: note: get vectype with 4 units of type int
test.c:60: note: vectype: vector(4) int
test.c:60: note: === vect_analyze_scalar_cycles ===
test.c:60: note: Analyze phi: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: Access function of PHI: {img_start_indx_21(D), +, 1}_2
test.c:60: note: step: 1,  init: img_start_indx_21(D)
test.c:60: note: Detected induction.
test.c:60: note: Analyze phi: .MEM_54 = PHI <.MEM_60(9), .MEM_59(17)>

test.c:60: note: === vect_analyze_scalar_cycles ===
test.c:60: note: Analyze phi: j_69 = PHI <j_32(6), 0(18)>

test.c:60: note: Access function of PHI: {0, +, 1}_3
test.c:60: note: step: 1,  init: 0
test.c:60: note: Detected induction.
test.c:60: note: Analyze phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:60: note: Analyze phi: ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:60: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:60: note: step: 4294967295,  init: 4096
test.c:60: note: Detected induction.
test.c:60: note: === vect_pattern_recog ===
test.c:60: note: vect_is_simple_use: operand i_63
test.c:60: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: type of def: 4.
test.c:60: note: vect_is_simple_use: operand D.7139_27
test.c:60: note: def_stmt: D.7139_27 = (unsigned int) D.7138_26;

test.c:60: note: type of def: 3.
test.c:60: note: vect_is_simple_use: operand i_63
test.c:60: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: type of def: 4.
test.c:60: note: === vect_mark_stmts_to_be_vectorized ===
test.c:60: note: init: phi relevant? i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: init: phi relevant? .MEM_54 = PHI <.MEM_60(9), .MEM_59(17)>

test.c:60: note: init: stmt relevant? pretmp.166_110 = i_63 * 4096;

test.c:60: note: init: phi relevant? j_69 = PHI <j_32(6), 0(18)>

test.c:60: note: init: phi relevant? .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:60: note: init: phi relevant? ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:60: note: init: stmt relevant? D.7138_26 = j_69 + pretmp.166_110;

test.c:60: note: init: stmt relevant? D.7139_27 = (unsigned int) D.7138_26;

test.c:60: note: init: stmt relevant? D.7140_28 = D.7139_27 * 4;

test.c:60: note: init: stmt relevant? D.7141_29 = image_11 + D.7140_28;

test.c:60: note: init: stmt relevant? D.7142_30 = i_63 * j_69;

test.c:60: note: init: stmt relevant? D.7143_31 = D.7142_30 % 255;

test.c:60: note: init: stmt relevant? *D.7141_29 = D.7143_31;

test.c:60: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: init: stmt relevant? j_32 = j_69 + 1;

test.c:60: note: init: stmt relevant? ivtmp.168_113 = ivtmp.168_115 - 1;

test.c:60: note: init: stmt relevant? if (ivtmp.168_113 != 0)

test.c:60: note: init: stmt relevant? i_33 = i_63 + 1;

test.c:60: note: init: stmt relevant? if (img_end_indx_23(D) > i_33)

test.c:60: note: worklist: examine stmt: *D.7141_29 = D.7143_31;

test.c:60: note: vect_is_simple_use: operand D.7143_31
test.c:60: note: def_stmt: D.7143_31 = D.7142_30 % 255;

test.c:60: note: type of def: 3.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: worklist: examine stmt: D.7143_31 = D.7142_30 % 255;

test.c:60: note: vect_is_simple_use: operand D.7142_30
test.c:60: note: def_stmt: D.7142_30 = i_63 * j_69;

test.c:60: note: type of def: 3.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: worklist: examine stmt: D.7142_30 = i_63 * j_69;

test.c:60: note: vect_is_simple_use: operand i_63
test.c:60: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: type of def: 4.
test.c:60: note: outer-loop def-stmt defining inner-loop stmt.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: vect_is_simple_use: operand j_69
test.c:60: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:60: note: type of def: 4.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: worklist: examine stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:60: note: vect_is_simple_use: operand j_32
test.c:60: note: def_stmt: j_32 = j_69 + 1;

test.c:60: note: type of def: 3.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: vect_is_simple_use: operand 0
test.c:60: note: worklist: examine stmt: j_32 = j_69 + 1;

test.c:60: note: vect_is_simple_use: operand j_69
test.c:60: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:60: note: type of def: 4.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: already marked relevant/live.
test.c:60: note: worklist: examine stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: vect_is_simple_use: operand i_33
test.c:60: note: def_stmt: i_33 = i_63 + 1;

test.c:60: note: type of def: 3.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: vect_is_simple_use: operand img_start_indx_21(D)
test.c:60: note: def_stmt: GIMPLE_NOP

test.c:60: note: worklist: examine stmt: i_33 = i_63 + 1;

test.c:60: note: vect_is_simple_use: operand i_63
test.c:60: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: type of def: 4.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: already marked relevant/live.
test.c:60: note: === vect_analyze_dependences ===
test.c:60: note: === vect_determine_vectorization_factor ===
test.c:60: note: ==> examining phi: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 4 units of type int
test.c:60: note: vectype: vector(4) int
test.c:60: note: vectype: vector(4) int
test.c:60: note: nunits = 4
test.c:60: note: ==> examining phi: .MEM_54 = PHI <.MEM_60(9), .MEM_59(17)>

test.c:60: note: ==> examining statement: pretmp.166_110 = i_63 * 4096;

test.c:60: note: skip.
test.c:60: note: ==> examining phi: j_69 = PHI <j_32(6), 0(18)>

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 4 units of type int
test.c:60: note: vectype: vector(4) int
test.c:60: note: vectype: vector(4) int
test.c:60: note: nunits = 4
test.c:60: note: ==> examining phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:60: note: ==> examining phi: ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:60: note: ==> examining statement: D.7138_26 = j_69 + pretmp.166_110;

test.c:60: note: skip.
test.c:60: note: ==> examining statement: D.7139_27 = (unsigned int) D.7138_26;

test.c:60: note: skip.
test.c:60: note: ==> examining statement: D.7140_28 = D.7139_27 * 4;

test.c:60: note: skip.
test.c:60: note: ==> examining statement: D.7141_29 = image_11 + D.7140_28;

test.c:60: note: skip.
test.c:60: note: ==> examining statement: D.7142_30 = i_63 * j_69;

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 4 units of type int
test.c:60: note: vectype: vector(4) int
test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 4 units of type int
test.c:60: note: vectype: vector(4) int
test.c:60: note: vectype: vector(4) int
test.c:60: note: nunits = 4
test.c:60: note: ==> examining statement: D.7143_31 = D.7142_30 % 255;

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 4 units of type int
test.c:60: note: vectype: vector(4) int
test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 4 units of type int
test.c:60: note: vectype: vector(4) int
test.c:60: note: vectype: vector(4) int
test.c:60: note: nunits = 4
test.c:60: note: ==> examining statement: *D.7141_29 = D.7143_31;

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 4 units of type int
test.c:60: note: vectype: vector(4) int
test.c:60: note: vectype: vector(4) int
test.c:60: note: nunits = 4
test.c:60: note: ==> examining statement: j_32 = j_69 + 1;

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 4 units of type int
test.c:60: note: vectype: vector(4) int
test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 4 units of type int
test.c:60: note: vectype: vector(4) int
test.c:60: note: vectype: vector(4) int
test.c:60: note: nunits = 4
test.c:60: note: ==> examining statement: ivtmp.168_113 = ivtmp.168_115 - 1;

test.c:60: note: skip.
test.c:60: note: ==> examining statement: if (ivtmp.168_113 != 0)

test.c:60: note: skip.
test.c:60: note: ==> examining statement: i_33 = i_63 + 1;

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 4 units of type int
test.c:60: note: vectype: vector(4) int
test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 4 units of type int
test.c:60: note: vectype: vector(4) int
test.c:60: note: vectype: vector(4) int
test.c:60: note: nunits = 4
test.c:60: note: ==> examining statement: if (img_end_indx_23(D) > i_33)

test.c:60: note: skip.
test.c:60: note: vectorization factor = 4
test.c:60: note: === vect_analyze_data_refs_alignment ===
test.c:60: note: vect_compute_data_ref_alignment:
test.c:60: note: inner step doesn't divide the vector-size.
test.c:60: note: Unknown alignment for access: *((int * restrict) D.7130_10 + (unsigned int) ((unsigned int) i_63 * 16384))
test.c:60: note: === vect_analyze_data_ref_accesses ===
test.c:60: note: strided access in outer loop.
test.c:60: note: not vectorized: complicated access pattern.
test.c:60: note: bad data access.
test.c:60: note: ***** Re-trying analysis with vector size 8

test.c:60: note: === vect_analyze_loop_form ===
test.c:60: note: ===== analyze_loop_nest_1 =====
test.c:60: note: === vect_analyze_loop_form ===
test.c:60: note: === get_loop_niters ===
test.c:60: note: ==> get_loop_niters:4096
test.c:60: note: Considering outer-loop vectorization.
test.c:60: note: === get_loop_niters ===
test.c:60: note: ==> get_loop_niters:((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:60: note: Symbolic number of iterations is ((unsigned int) ~img_start_indx_21(D) + (unsigned int) img_end_indx_23(D)) + 1
test.c:60: note: === vect_analyze_data_refs ===

test.c:60: note: analyze in outer-loop: *((int * restrict) D.7130_10 + (unsigned int) ((unsigned int) i_63 * 16384))
test.c:60: note: 	outer base_address: (int *) D.7130_10 + (unsigned int) ((unsigned int) img_start_indx_21(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:60: note: get vectype with 2 units of type int
test.c:60: note: vectype: vector(2) int
test.c:60: note: === vect_analyze_scalar_cycles ===
test.c:60: note: Analyze phi: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: Access function of PHI: {img_start_indx_21(D), +, 1}_2
test.c:60: note: step: 1,  init: img_start_indx_21(D)
test.c:60: note: Detected induction.
test.c:60: note: Analyze phi: .MEM_54 = PHI <.MEM_60(9), .MEM_59(17)>

test.c:60: note: === vect_analyze_scalar_cycles ===
test.c:60: note: Analyze phi: j_69 = PHI <j_32(6), 0(18)>

test.c:60: note: Access function of PHI: {0, +, 1}_3
test.c:60: note: step: 1,  init: 0
test.c:60: note: Detected induction.
test.c:60: note: Analyze phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:60: note: Analyze phi: ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:60: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:60: note: step: 4294967295,  init: 4096
test.c:60: note: Detected induction.
test.c:60: note: === vect_pattern_recog ===
test.c:60: note: vect_is_simple_use: operand i_63
test.c:60: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: type of def: 4.
test.c:60: note: vect_is_simple_use: operand D.7139_27
test.c:60: note: def_stmt: D.7139_27 = (unsigned int) D.7138_26;

test.c:60: note: type of def: 3.
test.c:60: note: vect_is_simple_use: operand i_63
test.c:60: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: type of def: 4.
test.c:60: note: === vect_mark_stmts_to_be_vectorized ===
test.c:60: note: init: phi relevant? i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: init: phi relevant? .MEM_54 = PHI <.MEM_60(9), .MEM_59(17)>

test.c:60: note: init: stmt relevant? pretmp.166_110 = i_63 * 4096;

test.c:60: note: init: phi relevant? j_69 = PHI <j_32(6), 0(18)>

test.c:60: note: init: phi relevant? .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:60: note: init: phi relevant? ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:60: note: init: stmt relevant? D.7138_26 = j_69 + pretmp.166_110;

test.c:60: note: init: stmt relevant? D.7139_27 = (unsigned int) D.7138_26;

test.c:60: note: init: stmt relevant? D.7140_28 = D.7139_27 * 4;

test.c:60: note: init: stmt relevant? D.7141_29 = image_11 + D.7140_28;

test.c:60: note: init: stmt relevant? D.7142_30 = i_63 * j_69;

test.c:60: note: init: stmt relevant? D.7143_31 = D.7142_30 % 255;

test.c:60: note: init: stmt relevant? *D.7141_29 = D.7143_31;

test.c:60: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: init: stmt relevant? j_32 = j_69 + 1;

test.c:60: note: init: stmt relevant? ivtmp.168_113 = ivtmp.168_115 - 1;

test.c:60: note: init: stmt relevant? if (ivtmp.168_113 != 0)

test.c:60: note: init: stmt relevant? i_33 = i_63 + 1;

test.c:60: note: init: stmt relevant? if (img_end_indx_23(D) > i_33)

test.c:60: note: worklist: examine stmt: *D.7141_29 = D.7143_31;

test.c:60: note: vect_is_simple_use: operand D.7143_31
test.c:60: note: def_stmt: D.7143_31 = D.7142_30 % 255;

test.c:60: note: type of def: 3.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: worklist: examine stmt: D.7143_31 = D.7142_30 % 255;

test.c:60: note: vect_is_simple_use: operand D.7142_30
test.c:60: note: def_stmt: D.7142_30 = i_63 * j_69;

test.c:60: note: type of def: 3.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: worklist: examine stmt: D.7142_30 = i_63 * j_69;

test.c:60: note: vect_is_simple_use: operand i_63
test.c:60: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: type of def: 4.
test.c:60: note: outer-loop def-stmt defining inner-loop stmt.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: vect_is_simple_use: operand j_69
test.c:60: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:60: note: type of def: 4.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: worklist: examine stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:60: note: vect_is_simple_use: operand j_32
test.c:60: note: def_stmt: j_32 = j_69 + 1;

test.c:60: note: type of def: 3.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: vect_is_simple_use: operand 0
test.c:60: note: worklist: examine stmt: j_32 = j_69 + 1;

test.c:60: note: vect_is_simple_use: operand j_69
test.c:60: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:60: note: type of def: 4.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: already marked relevant/live.
test.c:60: note: worklist: examine stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: vect_is_simple_use: operand i_33
test.c:60: note: def_stmt: i_33 = i_63 + 1;

test.c:60: note: type of def: 3.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: vect_is_simple_use: operand img_start_indx_21(D)
test.c:60: note: def_stmt: GIMPLE_NOP

test.c:60: note: worklist: examine stmt: i_33 = i_63 + 1;

test.c:60: note: vect_is_simple_use: operand i_63
test.c:60: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: type of def: 4.
test.c:60: note: mark relevant 4, live 0.
test.c:60: note: already marked relevant/live.
test.c:60: note: === vect_analyze_dependences ===
test.c:60: note: === vect_determine_vectorization_factor ===
test.c:60: note: ==> examining phi: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 2 units of type int
test.c:60: note: vectype: vector(2) int
test.c:60: note: vectype: vector(2) int
test.c:60: note: nunits = 2
test.c:60: note: ==> examining phi: .MEM_54 = PHI <.MEM_60(9), .MEM_59(17)>

test.c:60: note: ==> examining statement: pretmp.166_110 = i_63 * 4096;

test.c:60: note: skip.
test.c:60: note: ==> examining phi: j_69 = PHI <j_32(6), 0(18)>

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 2 units of type int
test.c:60: note: vectype: vector(2) int
test.c:60: note: vectype: vector(2) int
test.c:60: note: nunits = 2
test.c:60: note: ==> examining phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:60: note: ==> examining phi: ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:60: note: ==> examining statement: D.7138_26 = j_69 + pretmp.166_110;

test.c:60: note: skip.
test.c:60: note: ==> examining statement: D.7139_27 = (unsigned int) D.7138_26;

test.c:60: note: skip.
test.c:60: note: ==> examining statement: D.7140_28 = D.7139_27 * 4;

test.c:60: note: skip.
test.c:60: note: ==> examining statement: D.7141_29 = image_11 + D.7140_28;

test.c:60: note: skip.
test.c:60: note: ==> examining statement: D.7142_30 = i_63 * j_69;

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 2 units of type int
test.c:60: note: vectype: vector(2) int
test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 2 units of type int
test.c:60: note: vectype: vector(2) int
test.c:60: note: vectype: vector(2) int
test.c:60: note: nunits = 2
test.c:60: note: ==> examining statement: D.7143_31 = D.7142_30 % 255;

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 2 units of type int
test.c:60: note: vectype: vector(2) int
test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 2 units of type int
test.c:60: note: vectype: vector(2) int
test.c:60: note: vectype: vector(2) int
test.c:60: note: nunits = 2
test.c:60: note: ==> examining statement: *D.7141_29 = D.7143_31;

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 2 units of type int
test.c:60: note: vectype: vector(2) int
test.c:60: note: vectype: vector(2) int
test.c:60: note: nunits = 2
test.c:60: note: ==> examining statement: j_32 = j_69 + 1;

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 2 units of type int
test.c:60: note: vectype: vector(2) int
test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 2 units of type int
test.c:60: note: vectype: vector(2) int
test.c:60: note: vectype: vector(2) int
test.c:60: note: nunits = 2
test.c:60: note: ==> examining statement: ivtmp.168_113 = ivtmp.168_115 - 1;

test.c:60: note: skip.
test.c:60: note: ==> examining statement: if (ivtmp.168_113 != 0)

test.c:60: note: skip.
test.c:60: note: ==> examining statement: i_33 = i_63 + 1;

test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 2 units of type int
test.c:60: note: vectype: vector(2) int
test.c:60: note: get vectype for scalar type:  int
test.c:60: note: get vectype with 2 units of type int
test.c:60: note: vectype: vector(2) int
test.c:60: note: vectype: vector(2) int
test.c:60: note: nunits = 2
test.c:60: note: ==> examining statement: if (img_end_indx_23(D) > i_33)

test.c:60: note: skip.
test.c:60: note: vectorization factor = 2
test.c:60: note: === vect_analyze_data_refs_alignment ===
test.c:60: note: vect_compute_data_ref_alignment:
test.c:60: note: inner step doesn't divide the vector-size.
test.c:60: note: Unknown alignment for access: *((int * restrict) D.7130_10 + (unsigned int) ((unsigned int) i_63 * 16384))
test.c:60: note: === vect_analyze_data_ref_accesses ===
test.c:60: note: strided access in outer loop.
test.c:60: note: not vectorized: complicated access pattern.
test.c:60: note: bad data access.
test.c:61: note: ===== analyze_loop_nest =====
test.c:61: note: === vect_analyze_loop_form ===
test.c:61: note: === get_loop_niters ===
test.c:61: note: ==> get_loop_niters:4096
test.c:61: note: === vect_analyze_data_refs ===

test.c:61: note: get vectype with 4 units of type int
test.c:61: note: vectype: vector(4) int
test.c:61: note: === vect_analyze_scalar_cycles ===
test.c:61: note: Analyze phi: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: Access function of PHI: {0, +, 1}_3
test.c:61: note: step: 1,  init: 0
test.c:61: note: Detected induction.
test.c:61: note: Analyze phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:61: note: Analyze phi: ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:61: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:61: note: step: 4294967295,  init: 4096
test.c:61: note: Detected induction.
test.c:61: note: === vect_pattern_recog ===
test.c:61: note: vect_is_simple_use: operand D.7139_27
test.c:61: note: def_stmt: D.7139_27 = (unsigned int) D.7138_26;

test.c:61: note: type of def: 3.
test.c:61: note: vect_is_simple_use: operand i_63
test.c:61: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:61: note: type of def: 2.
test.c:61: note: === vect_mark_stmts_to_be_vectorized ===
test.c:61: note: init: phi relevant? j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: init: phi relevant? .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:61: note: init: phi relevant? ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:61: note: init: stmt relevant? D.7138_26 = j_69 + pretmp.166_110;

test.c:61: note: init: stmt relevant? D.7139_27 = (unsigned int) D.7138_26;

test.c:61: note: init: stmt relevant? D.7140_28 = D.7139_27 * 4;

test.c:61: note: init: stmt relevant? D.7141_29 = image_11 + D.7140_28;

test.c:61: note: init: stmt relevant? D.7142_30 = i_63 * j_69;

test.c:61: note: init: stmt relevant? D.7143_31 = D.7142_30 % 255;

test.c:61: note: init: stmt relevant? *D.7141_29 = D.7143_31;

test.c:61: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:61: note: mark relevant 4, live 0.
test.c:61: note: init: stmt relevant? j_32 = j_69 + 1;

test.c:61: note: init: stmt relevant? ivtmp.168_113 = ivtmp.168_115 - 1;

test.c:61: note: init: stmt relevant? if (ivtmp.168_113 != 0)

test.c:61: note: worklist: examine stmt: *D.7141_29 = D.7143_31;

test.c:61: note: vect_is_simple_use: operand D.7143_31
test.c:61: note: def_stmt: D.7143_31 = D.7142_30 % 255;

test.c:61: note: type of def: 3.
test.c:61: note: mark relevant 4, live 0.
test.c:61: note: worklist: examine stmt: D.7143_31 = D.7142_30 % 255;

test.c:61: note: vect_is_simple_use: operand D.7142_30
test.c:61: note: def_stmt: D.7142_30 = i_63 * j_69;

test.c:61: note: type of def: 3.
test.c:61: note: mark relevant 4, live 0.
test.c:61: note: worklist: examine stmt: D.7142_30 = i_63 * j_69;

test.c:61: note: vect_is_simple_use: operand i_63
test.c:61: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:61: note: type of def: 2.
test.c:61: note: def_stmt is out of loop.
test.c:61: note: vect_is_simple_use: operand j_69
test.c:61: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: type of def: 4.
test.c:61: note: mark relevant 4, live 0.
test.c:61: note: worklist: examine stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: vect_is_simple_use: operand j_32
test.c:61: note: def_stmt: j_32 = j_69 + 1;

test.c:61: note: type of def: 3.
test.c:61: note: mark relevant 4, live 0.
test.c:61: note: vect_is_simple_use: operand 0
test.c:61: note: worklist: examine stmt: j_32 = j_69 + 1;

test.c:61: note: vect_is_simple_use: operand j_69
test.c:61: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: type of def: 4.
test.c:61: note: mark relevant 4, live 0.
test.c:61: note: already marked relevant/live.
test.c:61: note: === vect_analyze_dependences ===
test.c:61: note: === vect_determine_vectorization_factor ===
test.c:61: note: ==> examining phi: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 4 units of type int
test.c:61: note: vectype: vector(4) int
test.c:61: note: vectype: vector(4) int
test.c:61: note: nunits = 4
test.c:61: note: ==> examining phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:61: note: ==> examining phi: ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:61: note: ==> examining statement: D.7138_26 = j_69 + pretmp.166_110;

test.c:61: note: skip.
test.c:61: note: ==> examining statement: D.7139_27 = (unsigned int) D.7138_26;

test.c:61: note: skip.
test.c:61: note: ==> examining statement: D.7140_28 = D.7139_27 * 4;

test.c:61: note: skip.
test.c:61: note: ==> examining statement: D.7141_29 = image_11 + D.7140_28;

test.c:61: note: skip.
test.c:61: note: ==> examining statement: D.7142_30 = i_63 * j_69;

test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 4 units of type int
test.c:61: note: vectype: vector(4) int
test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 4 units of type int
test.c:61: note: vectype: vector(4) int
test.c:61: note: vectype: vector(4) int
test.c:61: note: nunits = 4
test.c:61: note: ==> examining statement: D.7143_31 = D.7142_30 % 255;

test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 4 units of type int
test.c:61: note: vectype: vector(4) int
test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 4 units of type int
test.c:61: note: vectype: vector(4) int
test.c:61: note: vectype: vector(4) int
test.c:61: note: nunits = 4
test.c:61: note: ==> examining statement: *D.7141_29 = D.7143_31;

test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 4 units of type int
test.c:61: note: vectype: vector(4) int
test.c:61: note: vectype: vector(4) int
test.c:61: note: nunits = 4
test.c:61: note: ==> examining statement: j_32 = j_69 + 1;

test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 4 units of type int
test.c:61: note: vectype: vector(4) int
test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 4 units of type int
test.c:61: note: vectype: vector(4) int
test.c:61: note: vectype: vector(4) int
test.c:61: note: nunits = 4
test.c:61: note: ==> examining statement: ivtmp.168_113 = ivtmp.168_115 - 1;

test.c:61: note: skip.
test.c:61: note: ==> examining statement: if (ivtmp.168_113 != 0)

test.c:61: note: skip.
test.c:61: note: vectorization factor = 4
test.c:61: note: === vect_analyze_data_refs_alignment ===
test.c:61: note: vect_compute_data_ref_alignment:
test.c:61: note: can't force alignment of ref: *D.7141_29
test.c:61: note: === vect_analyze_data_ref_accesses ===
test.c:61: note: === vect_prune_runtime_alias_test_list ===
test.c:61: note: === vect_enhance_data_refs_alignment ===
test.c:61: note: Unknown misalignment, is_packed = 0
test.c:61: note: vect_can_advance_ivs_p:
test.c:61: note: Analyze phi: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: Access function of PHI: {0, +, 1}_3
test.c:61: note: Analyze phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:61: note: virtual phi. skip.
test.c:61: note: Analyze phi: ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:61: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:61: note: Alignment of access forced using peeling.
test.c:61: note: Peeling for alignment will be applied.
test.c:61: note: === vect_analyze_slp ===
test.c:61: note: === vect_make_slp_decision ===
test.c:61: note: === vect_detect_hybrid_slp ===
test.c:61: note: === vect_analyze_loop_operations ===
test.c:61: note: examining phi: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: === vectorizable_induction ===
test.c:61: note: vect_model_induction_cost: inside_cost = 1, outside_cost = 2 .
test.c:61: note: examining phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:61: note: examining phi: ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:61: note: ==> examining statement: D.7138_26 = j_69 + pretmp.166_110;

test.c:61: note: irrelevant.
test.c:61: note: ==> examining statement: D.7139_27 = (unsigned int) D.7138_26;

test.c:61: note: irrelevant.
test.c:61: note: ==> examining statement: D.7140_28 = D.7139_27 * 4;

test.c:61: note: irrelevant.
test.c:61: note: ==> examining statement: D.7141_29 = image_11 + D.7140_28;

test.c:61: note: irrelevant.
test.c:61: note: ==> examining statement: D.7142_30 = i_63 * j_69;

test.c:61: note: vect_is_simple_use: operand i_63
test.c:61: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:61: note: type of def: 2.
test.c:61: note: get vectype with 4 units of type int
test.c:61: note: vectype: vector(4) int
test.c:61: note: vect_is_simple_use: operand j_69
test.c:61: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: type of def: 4.
test.c:61: note: === vectorizable_operation ===
test.c:61: note: vect_model_simple_cost: inside_cost = 1, outside_cost = 1 .
test.c:61: note: ==> examining statement: D.7143_31 = D.7142_30 % 255;

test.c:61: note: vect_is_simple_use: operand D.7142_30
test.c:61: note: def_stmt: D.7142_30 = i_63 * j_69;

test.c:61: note: type of def: 3.
test.c:61: note: vect_is_simple_use: operand 255
test.c:61: note: op not supported by target.
test.c:61: note: not vectorized: relevant stmt not supported: D.7143_31 = D.7142_30 % 255;

test.c:61: note: bad operation or unsupported loop bound.
test.c:61: note: ***** Re-trying analysis with vector size 8

test.c:61: note: === vect_analyze_loop_form ===
test.c:61: note: === get_loop_niters ===
test.c:61: note: ==> get_loop_niters:4096
test.c:61: note: === vect_analyze_data_refs ===

test.c:61: note: get vectype with 2 units of type int
test.c:61: note: vectype: vector(2) int
test.c:61: note: === vect_analyze_scalar_cycles ===
test.c:61: note: Analyze phi: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: Access function of PHI: {0, +, 1}_3
test.c:61: note: step: 1,  init: 0
test.c:61: note: Detected induction.
test.c:61: note: Analyze phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:61: note: Analyze phi: ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:61: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:61: note: step: 4294967295,  init: 4096
test.c:61: note: Detected induction.
test.c:61: note: === vect_pattern_recog ===
test.c:61: note: vect_is_simple_use: operand D.7139_27
test.c:61: note: def_stmt: D.7139_27 = (unsigned int) D.7138_26;

test.c:61: note: type of def: 3.
test.c:61: note: vect_is_simple_use: operand i_63
test.c:61: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:61: note: type of def: 2.
test.c:61: note: === vect_mark_stmts_to_be_vectorized ===
test.c:61: note: init: phi relevant? j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: init: phi relevant? .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:61: note: init: phi relevant? ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:61: note: init: stmt relevant? D.7138_26 = j_69 + pretmp.166_110;

test.c:61: note: init: stmt relevant? D.7139_27 = (unsigned int) D.7138_26;

test.c:61: note: init: stmt relevant? D.7140_28 = D.7139_27 * 4;

test.c:61: note: init: stmt relevant? D.7141_29 = image_11 + D.7140_28;

test.c:61: note: init: stmt relevant? D.7142_30 = i_63 * j_69;

test.c:61: note: init: stmt relevant? D.7143_31 = D.7142_30 % 255;

test.c:61: note: init: stmt relevant? *D.7141_29 = D.7143_31;

test.c:61: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:61: note: mark relevant 4, live 0.
test.c:61: note: init: stmt relevant? j_32 = j_69 + 1;

test.c:61: note: init: stmt relevant? ivtmp.168_113 = ivtmp.168_115 - 1;

test.c:61: note: init: stmt relevant? if (ivtmp.168_113 != 0)

test.c:61: note: worklist: examine stmt: *D.7141_29 = D.7143_31;

test.c:61: note: vect_is_simple_use: operand D.7143_31
test.c:61: note: def_stmt: D.7143_31 = D.7142_30 % 255;

test.c:61: note: type of def: 3.
test.c:61: note: mark relevant 4, live 0.
test.c:61: note: worklist: examine stmt: D.7143_31 = D.7142_30 % 255;

test.c:61: note: vect_is_simple_use: operand D.7142_30
test.c:61: note: def_stmt: D.7142_30 = i_63 * j_69;

test.c:61: note: type of def: 3.
test.c:61: note: mark relevant 4, live 0.
test.c:61: note: worklist: examine stmt: D.7142_30 = i_63 * j_69;

test.c:61: note: vect_is_simple_use: operand i_63
test.c:61: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:61: note: type of def: 2.
test.c:61: note: def_stmt is out of loop.
test.c:61: note: vect_is_simple_use: operand j_69
test.c:61: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: type of def: 4.
test.c:61: note: mark relevant 4, live 0.
test.c:61: note: worklist: examine stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: vect_is_simple_use: operand j_32
test.c:61: note: def_stmt: j_32 = j_69 + 1;

test.c:61: note: type of def: 3.
test.c:61: note: mark relevant 4, live 0.
test.c:61: note: vect_is_simple_use: operand 0
test.c:61: note: worklist: examine stmt: j_32 = j_69 + 1;

test.c:61: note: vect_is_simple_use: operand j_69
test.c:61: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: type of def: 4.
test.c:61: note: mark relevant 4, live 0.
test.c:61: note: already marked relevant/live.
test.c:61: note: === vect_analyze_dependences ===
test.c:61: note: === vect_determine_vectorization_factor ===
test.c:61: note: ==> examining phi: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 2 units of type int
test.c:61: note: vectype: vector(2) int
test.c:61: note: vectype: vector(2) int
test.c:61: note: nunits = 2
test.c:61: note: ==> examining phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:61: note: ==> examining phi: ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:61: note: ==> examining statement: D.7138_26 = j_69 + pretmp.166_110;

test.c:61: note: skip.
test.c:61: note: ==> examining statement: D.7139_27 = (unsigned int) D.7138_26;

test.c:61: note: skip.
test.c:61: note: ==> examining statement: D.7140_28 = D.7139_27 * 4;

test.c:61: note: skip.
test.c:61: note: ==> examining statement: D.7141_29 = image_11 + D.7140_28;

test.c:61: note: skip.
test.c:61: note: ==> examining statement: D.7142_30 = i_63 * j_69;

test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 2 units of type int
test.c:61: note: vectype: vector(2) int
test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 2 units of type int
test.c:61: note: vectype: vector(2) int
test.c:61: note: vectype: vector(2) int
test.c:61: note: nunits = 2
test.c:61: note: ==> examining statement: D.7143_31 = D.7142_30 % 255;

test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 2 units of type int
test.c:61: note: vectype: vector(2) int
test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 2 units of type int
test.c:61: note: vectype: vector(2) int
test.c:61: note: vectype: vector(2) int
test.c:61: note: nunits = 2
test.c:61: note: ==> examining statement: *D.7141_29 = D.7143_31;

test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 2 units of type int
test.c:61: note: vectype: vector(2) int
test.c:61: note: vectype: vector(2) int
test.c:61: note: nunits = 2
test.c:61: note: ==> examining statement: j_32 = j_69 + 1;

test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 2 units of type int
test.c:61: note: vectype: vector(2) int
test.c:61: note: get vectype for scalar type:  int
test.c:61: note: get vectype with 2 units of type int
test.c:61: note: vectype: vector(2) int
test.c:61: note: vectype: vector(2) int
test.c:61: note: nunits = 2
test.c:61: note: ==> examining statement: ivtmp.168_113 = ivtmp.168_115 - 1;

test.c:61: note: skip.
test.c:61: note: ==> examining statement: if (ivtmp.168_113 != 0)

test.c:61: note: skip.
test.c:61: note: vectorization factor = 2
test.c:61: note: === vect_analyze_data_refs_alignment ===
test.c:61: note: vect_compute_data_ref_alignment:
test.c:61: note: can't force alignment of ref: *D.7141_29
test.c:61: note: === vect_analyze_data_ref_accesses ===
test.c:61: note: === vect_prune_runtime_alias_test_list ===
test.c:61: note: === vect_enhance_data_refs_alignment ===
test.c:61: note: Unknown misalignment, is_packed = 0
test.c:61: note: vect_can_advance_ivs_p:
test.c:61: note: Analyze phi: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: Access function of PHI: {0, +, 1}_3
test.c:61: note: Analyze phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:61: note: virtual phi. skip.
test.c:61: note: Analyze phi: ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:61: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:61: note: Alignment of access forced using peeling.
test.c:61: note: Peeling for alignment will be applied.
test.c:61: note: === vect_analyze_slp ===
test.c:61: note: === vect_make_slp_decision ===
test.c:61: note: === vect_detect_hybrid_slp ===
test.c:61: note: === vect_analyze_loop_operations ===
test.c:61: note: examining phi: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: === vectorizable_induction ===
test.c:61: note: vect_model_induction_cost: inside_cost = 1, outside_cost = 2 .
test.c:61: note: examining phi: .MEM_74 = PHI <.MEM_60(6), .MEM_54(18)>

test.c:61: note: examining phi: ivtmp.168_115 = PHI <ivtmp.168_113(6), 4096(18)>

test.c:61: note: ==> examining statement: D.7138_26 = j_69 + pretmp.166_110;

test.c:61: note: irrelevant.
test.c:61: note: ==> examining statement: D.7139_27 = (unsigned int) D.7138_26;

test.c:61: note: irrelevant.
test.c:61: note: ==> examining statement: D.7140_28 = D.7139_27 * 4;

test.c:61: note: irrelevant.
test.c:61: note: ==> examining statement: D.7141_29 = image_11 + D.7140_28;

test.c:61: note: irrelevant.
test.c:61: note: ==> examining statement: D.7142_30 = i_63 * j_69;

test.c:61: note: vect_is_simple_use: operand i_63
test.c:61: note: def_stmt: i_63 = PHI <i_33(9), img_start_indx_21(D)(17)>

test.c:61: note: type of def: 2.
test.c:61: note: get vectype with 2 units of type int
test.c:61: note: vectype: vector(2) int
test.c:61: note: vect_is_simple_use: operand j_69
test.c:61: note: def_stmt: j_69 = PHI <j_32(6), 0(18)>

test.c:61: note: type of def: 4.
test.c:61: note: === vectorizable_operation ===
test.c:61: note: vect_model_simple_cost: inside_cost = 1, outside_cost = 1 .
test.c:61: note: ==> examining statement: D.7143_31 = D.7142_30 % 255;

test.c:61: note: vect_is_simple_use: operand D.7142_30
test.c:61: note: def_stmt: D.7142_30 = i_63 * j_69;

test.c:61: note: type of def: 3.
test.c:61: note: vect_is_simple_use: operand 255
test.c:61: note: op not supported by target.
test.c:61: note: not vectorized: relevant stmt not supported: D.7143_31 = D.7142_30 % 255;

test.c:61: note: bad operation or unsupported loop bound.
test.c:56: note: ===== analyze_loop_nest =====
test.c:56: note: === vect_analyze_loop_form ===
test.c:56: note: === get_loop_niters ===
test.c:56: note: ==> get_loop_niters:256
test.c:56: note: === vect_analyze_data_refs ===

test.c:56: note: get vectype with 4 units of type int
test.c:56: note: vectype: vector(4) int
test.c:56: note: === vect_analyze_scalar_cycles ===
test.c:56: note: Analyze phi: i_64 = PHI <i_20(4), 0(2)>

test.c:56: note: Access function of PHI: {0, +, 1}_1
test.c:56: note: step: 1,  init: 0
test.c:56: note: Detected induction.
test.c:56: note: Analyze phi: .MEM_73 = PHI <.MEM_59(4), .MEM_58(D)(2)>

test.c:56: note: Analyze phi: ivtmp.169_112 = PHI <ivtmp.169_111(4), 256(2)>

test.c:56: note: Access function of PHI: {256, +, 4294967295}_1
test.c:56: note: step: 4294967295,  init: 256
test.c:56: note: Detected induction.
test.c:56: note: === vect_pattern_recog ===
test.c:56: note: vect_is_simple_use: operand i.6_17
test.c:56: note: def_stmt: i.6_17 = (unsigned int) i_64;

test.c:56: note: type of def: 3.
test.c:56: note: === vect_mark_stmts_to_be_vectorized ===
test.c:56: note: init: phi relevant? i_64 = PHI <i_20(4), 0(2)>

test.c:56: note: init: phi relevant? .MEM_73 = PHI <.MEM_59(4), .MEM_58(D)(2)>

test.c:56: note: init: phi relevant? ivtmp.169_112 = PHI <ivtmp.169_111(4), 256(2)>

test.c:56: note: init: stmt relevant? i.6_17 = (unsigned int) i_64;

test.c:56: note: init: stmt relevant? D.7135_18 = i.6_17 * 4;

test.c:56: note: init: stmt relevant? D.7136_19 = histogram_15 + D.7135_18;

test.c:56: note: init: stmt relevant? *D.7136_19 = 0;

test.c:56: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:56: note: mark relevant 4, live 0.
test.c:56: note: init: stmt relevant? i_20 = i_64 + 1;

test.c:56: note: init: stmt relevant? ivtmp.169_111 = ivtmp.169_112 - 1;

test.c:56: note: init: stmt relevant? if (ivtmp.169_111 != 0)

test.c:56: note: worklist: examine stmt: *D.7136_19 = 0;

test.c:56: note: === vect_analyze_dependences ===
test.c:56: note: === vect_determine_vectorization_factor ===
test.c:56: note: ==> examining phi: i_64 = PHI <i_20(4), 0(2)>

test.c:56: note: ==> examining phi: .MEM_73 = PHI <.MEM_59(4), .MEM_58(D)(2)>

test.c:56: note: ==> examining phi: ivtmp.169_112 = PHI <ivtmp.169_111(4), 256(2)>

test.c:56: note: ==> examining statement: i.6_17 = (unsigned int) i_64;

test.c:56: note: skip.
test.c:56: note: ==> examining statement: D.7135_18 = i.6_17 * 4;

test.c:56: note: skip.
test.c:56: note: ==> examining statement: D.7136_19 = histogram_15 + D.7135_18;

test.c:56: note: skip.
test.c:56: note: ==> examining statement: *D.7136_19 = 0;

test.c:56: note: get vectype for scalar type:  int
test.c:56: note: get vectype with 4 units of type int
test.c:56: note: vectype: vector(4) int
test.c:56: note: vectype: vector(4) int
test.c:56: note: nunits = 4
test.c:56: note: ==> examining statement: i_20 = i_64 + 1;

test.c:56: note: skip.
test.c:56: note: ==> examining statement: ivtmp.169_111 = ivtmp.169_112 - 1;

test.c:56: note: skip.
test.c:56: note: ==> examining statement: if (ivtmp.169_111 != 0)

test.c:56: note: skip.
test.c:56: note: vectorization factor = 4
test.c:56: note: === vect_analyze_data_refs_alignment ===
test.c:56: note: vect_compute_data_ref_alignment:
test.c:56: note: can't force alignment of ref: *D.7136_19
test.c:56: note: === vect_analyze_data_ref_accesses ===
test.c:56: note: === vect_prune_runtime_alias_test_list ===
test.c:56: note: === vect_enhance_data_refs_alignment ===
test.c:56: note: Unknown misalignment, is_packed = 0
test.c:56: note: vect_can_advance_ivs_p:
test.c:56: note: Analyze phi: i_64 = PHI <i_20(4), 0(2)>

test.c:56: note: Access function of PHI: {0, +, 1}_1
test.c:56: note: Analyze phi: .MEM_73 = PHI <.MEM_59(4), .MEM_58(D)(2)>

test.c:56: note: virtual phi. skip.
test.c:56: note: Analyze phi: ivtmp.169_112 = PHI <ivtmp.169_111(4), 256(2)>

test.c:56: note: Access function of PHI: {256, +, 4294967295}_1
test.c:56: note: Alignment of access forced using peeling.
test.c:56: note: Peeling for alignment will be applied.
test.c:56: note: === vect_analyze_slp ===
test.c:56: note: === vect_make_slp_decision ===
test.c:56: note: === vect_detect_hybrid_slp ===
test.c:56: note: === vect_analyze_loop_operations ===
test.c:56: note: examining phi: i_64 = PHI <i_20(4), 0(2)>

test.c:56: note: examining phi: .MEM_73 = PHI <.MEM_59(4), .MEM_58(D)(2)>

test.c:56: note: examining phi: ivtmp.169_112 = PHI <ivtmp.169_111(4), 256(2)>

test.c:56: note: ==> examining statement: i.6_17 = (unsigned int) i_64;

test.c:56: note: irrelevant.
test.c:56: note: ==> examining statement: D.7135_18 = i.6_17 * 4;

test.c:56: note: irrelevant.
test.c:56: note: ==> examining statement: D.7136_19 = histogram_15 + D.7135_18;

test.c:56: note: irrelevant.
test.c:56: note: ==> examining statement: *D.7136_19 = 0;

test.c:56: note: vect_is_simple_use: operand 0
test.c:56: note: vect_model_store_cost: aligned.
test.c:56: note: vect_model_store_cost: inside_cost = 1, outside_cost = 1 .
test.c:56: note: ==> examining statement: i_20 = i_64 + 1;

test.c:56: note: irrelevant.
test.c:56: note: ==> examining statement: ivtmp.169_111 = ivtmp.169_112 - 1;

test.c:56: note: irrelevant.
test.c:56: note: ==> examining statement: if (ivtmp.169_111 != 0)

test.c:56: note: irrelevant.
test.c:56: note: vectorization_factor = 4, niters = 256
test.c:56: note: === vect_update_slp_costs_according_to_vf ===
test.c:56: note: cost model disabled.
test.c:56: note: epilog loop required.
test.c:56: note: vect_can_advance_ivs_p:
test.c:56: note: Analyze phi: i_64 = PHI <i_20(4), 0(2)>

test.c:56: note: Access function of PHI: {0, +, 1}_1
test.c:56: note: Analyze phi: .MEM_73 = PHI <.MEM_59(4), .MEM_58(D)(2)>

test.c:56: note: virtual phi. skip.
test.c:56: note: Analyze phi: ivtmp.169_112 = PHI <ivtmp.169_111(4), 256(2)>

test.c:56: note: Access function of PHI: {256, +, 4294967295}_1
test.c:56: note: === vec_transform_loop ===
test.c:56: note: === vect_do_peeling_for_alignment ===
test.c:56: note: created vect_p.173_109
test.c:56: note: niters for prolog loop: -(((unsigned int) vect_p.173_109 & 15) >> 2) & 3
test.c:56: note: Profitability threshold is 3 loop iterations.
test.c:56: note: === vect_update_inits_of_dr ===
test.c:56: note: === vect_do_peeling_for_loop_bound ===
test.c:56: note: vect_update_ivs_after_vectorizer: phi: i_64 = PHI <i_20(4), i_130(31)>

test.c:56: note: vect_update_ivs_after_vectorizer: phi: .MEM_73 = PHI <.MEM_59(4), .MEM_132(31)>

test.c:56: note: virtual phi. skip.
test.c:56: note: vect_update_ivs_after_vectorizer: phi: ivtmp.169_112 = PHI <ivtmp.169_111(4), ivtmp.169_133(31)>

test.c:56: note: ------>vectorizing phi: i_64 = PHI <i_20(4), i_130(36)>

test.c:56: note: ------>vectorizing phi: .MEM_73 = PHI <.MEM_59(4), .MEM_132(36)>

test.c:56: note: ------>vectorizing phi: ivtmp.169_112 = PHI <ivtmp.169_111(4), ivtmp.169_133(36)>

test.c:56: note: ------>vectorizing statement: i.6_17 = (unsigned int) i_64;

test.c:56: note: ------>vectorizing statement: D.7135_18 = i.6_17 * 4;

test.c:56: note: ------>vectorizing statement: D.7136_19 = histogram_15 + D.7135_18;

test.c:56: note: ------>vectorizing statement: *D.7136_19 = 0;

test.c:56: note: transform statement.
test.c:56: note: vect_is_simple_use: operand 0
test.c:56: note: transform store. ncopies = 1
test.c:56: note: vect_get_vec_def_for_operand: 0
test.c:56: note: vect_is_simple_use: operand 0
test.c:56: note: 
test.c:56: note: get vectype with 4 units of type int
test.c:56: note: vectype: vector(4) int
test.c:56: note: Create vector_cst. nunits = 4
test.c:56: note: created new init_stmt: vect_cst_.182_160 = { 0, 0, 0, 0 };

test.c:56: note: create vector_type-pointer variable to type: vector(4) int*D.7133_14
test.c:56: note: created vect_p.186_163
test.c:56: note: add new stmt: MEM[(int *)vect_p.183_164] = vect_cst_.182_160;

test.c:56: note: ------>vectorizing statement: i_20 = i_64 + 1;

test.c:56: note: ------>vectorizing statement: ivtmp.169_111 = ivtmp.169_112 - 1;

test.c:56: note: ------>vectorizing statement: vect_p.183_165 = vect_p.183_164 + 16;

test.c:56: note: ------>vectorizing statement: if (ivtmp.169_111 != 0)

test.c:56: note: LOOP VECTORIZED.
test.c:47: note: vectorized 1 loops in function.

test.c:84: note: ===== analyze_loop_nest =====
test.c:84: note: === vect_analyze_loop_form ===
test.c:84: note: ===== analyze_loop_nest_1 =====
test.c:84: note: === vect_analyze_loop_form ===
test.c:84: note: === get_loop_niters ===
test.c:84: note: ==> get_loop_niters:4096
test.c:84: note: Considering outer-loop vectorization.
test.c:84: note: split exit edge.
test.c:84: note: === get_loop_niters ===
test.c:84: note: ==> get_loop_niters:((unsigned int) ~img_start_indx_7(D) + (unsigned int) img_end_indx_9(D)) + 1
test.c:84: note: Symbolic number of iterations is ((unsigned int) ~img_start_indx_7(D) + (unsigned int) img_end_indx_9(D)) + 1
test.c:84: note: === vect_analyze_data_refs ===

test.c:84: note: analyze in outer-loop: *((int * restrict) D.7119_5 + (unsigned int) ((unsigned int) i_30 * 16384))
test.c:84: note: 	outer base_address: (int *) D.7119_5 + (unsigned int) ((unsigned int) img_start_indx_7(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:84: note: get vectype with 4 units of type int
test.c:84: note: vectype: vector(4) int
test.c:84: note: not vectorized: data ref analysis failed D.7126_22 = a9_gray_level_mapping[D.7125_21];

test.c:84: note: bad data references.
test.c:84: note: ***** Re-trying analysis with vector size 8

test.c:84: note: === vect_analyze_loop_form ===
test.c:84: note: ===== analyze_loop_nest_1 =====
test.c:84: note: === vect_analyze_loop_form ===
test.c:84: note: === get_loop_niters ===
test.c:84: note: ==> get_loop_niters:4096
test.c:84: note: Considering outer-loop vectorization.
test.c:84: note: === get_loop_niters ===
test.c:84: note: ==> get_loop_niters:((unsigned int) ~img_start_indx_7(D) + (unsigned int) img_end_indx_9(D)) + 1
test.c:84: note: Symbolic number of iterations is ((unsigned int) ~img_start_indx_7(D) + (unsigned int) img_end_indx_9(D)) + 1
test.c:84: note: === vect_analyze_data_refs ===

test.c:84: note: analyze in outer-loop: *((int * restrict) D.7119_5 + (unsigned int) ((unsigned int) i_30 * 16384))
test.c:84: note: 	outer base_address: (int *) D.7119_5 + (unsigned int) ((unsigned int) img_start_indx_7(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:84: note: get vectype with 2 units of type int
test.c:84: note: vectype: vector(2) int
test.c:84: note: not vectorized: data ref analysis failed D.7126_22 = a9_gray_level_mapping[D.7125_21];

test.c:84: note: bad data references.
test.c:85: note: ===== analyze_loop_nest =====
test.c:85: note: === vect_analyze_loop_form ===
test.c:85: note: === get_loop_niters ===
test.c:85: note: ==> get_loop_niters:4096
test.c:85: note: === vect_analyze_data_refs ===

test.c:85: note: get vectype with 4 units of type int
test.c:85: note: vectype: vector(4) int
test.c:85: note: not vectorized: data ref analysis failed D.7126_22 = a9_gray_level_mapping[D.7125_21];

test.c:85: note: bad data references.
test.c:85: note: ***** Re-trying analysis with vector size 8

test.c:85: note: === vect_analyze_loop_form ===
test.c:85: note: === get_loop_niters ===
test.c:85: note: ==> get_loop_niters:4096
test.c:85: note: === vect_analyze_data_refs ===

test.c:85: note: get vectype with 2 units of type int
test.c:85: note: vectype: vector(2) int
test.c:85: note: not vectorized: data ref analysis failed D.7126_22 = a9_gray_level_mapping[D.7125_21];

test.c:85: note: bad data references.
test.c:77: note: vectorized 0 loops in function.

test.c:100: note: ===== analyze_loop_nest =====
test.c:100: note: === vect_analyze_loop_form ===
test.c:100: note: ===== analyze_loop_nest_1 =====
test.c:100: note: === vect_analyze_loop_form ===
test.c:100: note: === get_loop_niters ===
test.c:100: note: ==> get_loop_niters:4096
test.c:100: note: Considering outer-loop vectorization.
test.c:100: note: split exit edge.
test.c:100: note: === get_loop_niters ===
test.c:100: note: ==> get_loop_niters:((unsigned int) ~img_start_indx_7(D) + (unsigned int) img_end_indx_9(D)) + 1
test.c:100: note: Symbolic number of iterations is ((unsigned int) ~img_start_indx_7(D) + (unsigned int) img_end_indx_9(D)) + 1
test.c:100: note: === vect_analyze_data_refs ===

test.c:100: note: analyze in outer-loop: *((int * restrict) D.7108_5 + (unsigned int) ((unsigned int) i_30 * 16384))
test.c:100: note: 	outer base_address: (int *) D.7108_5 + (unsigned int) ((unsigned int) img_start_indx_7(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:100: note: get vectype with 4 units of type int
test.c:100: note: vectype: vector(4) int
test.c:100: note: not vectorized: data ref analysis failed D.7115_22 = a9_gray_level_mapping[D.7114_21];

test.c:100: note: bad data references.
test.c:100: note: ***** Re-trying analysis with vector size 8

test.c:100: note: === vect_analyze_loop_form ===
test.c:100: note: ===== analyze_loop_nest_1 =====
test.c:100: note: === vect_analyze_loop_form ===
test.c:100: note: === get_loop_niters ===
test.c:100: note: ==> get_loop_niters:4096
test.c:100: note: Considering outer-loop vectorization.
test.c:100: note: === get_loop_niters ===
test.c:100: note: ==> get_loop_niters:((unsigned int) ~img_start_indx_7(D) + (unsigned int) img_end_indx_9(D)) + 1
test.c:100: note: Symbolic number of iterations is ((unsigned int) ~img_start_indx_7(D) + (unsigned int) img_end_indx_9(D)) + 1
test.c:100: note: === vect_analyze_data_refs ===

test.c:100: note: analyze in outer-loop: *((int * restrict) D.7108_5 + (unsigned int) ((unsigned int) i_30 * 16384))
test.c:100: note: 	outer base_address: (int *) D.7108_5 + (unsigned int) ((unsigned int) img_start_indx_7(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:100: note: get vectype with 2 units of type int
test.c:100: note: vectype: vector(2) int
test.c:100: note: not vectorized: data ref analysis failed D.7115_22 = a9_gray_level_mapping[D.7114_21];

test.c:100: note: bad data references.
test.c:101: note: ===== analyze_loop_nest =====
test.c:101: note: === vect_analyze_loop_form ===
test.c:101: note: === get_loop_niters ===
test.c:101: note: ==> get_loop_niters:4096
test.c:101: note: === vect_analyze_data_refs ===

test.c:101: note: get vectype with 4 units of type int
test.c:101: note: vectype: vector(4) int
test.c:101: note: not vectorized: data ref analysis failed D.7115_22 = a9_gray_level_mapping[D.7114_21];

test.c:101: note: bad data references.
test.c:101: note: ***** Re-trying analysis with vector size 8

test.c:101: note: === vect_analyze_loop_form ===
test.c:101: note: === get_loop_niters ===
test.c:101: note: ==> get_loop_niters:4096
test.c:101: note: === vect_analyze_data_refs ===

test.c:101: note: get vectype with 2 units of type int
test.c:101: note: vectype: vector(2) int
test.c:101: note: not vectorized: data ref analysis failed D.7115_22 = a9_gray_level_mapping[D.7114_21];

test.c:101: note: bad data references.
test.c:93: note: vectorized 0 loops in function.

test.c:127: note: ===== analyze_loop_nest =====
test.c:127: note: === vect_analyze_loop_form ===
test.c:127: note: === get_loop_niters ===
test.c:127: note: ==> get_loop_niters:256
test.c:127: note: === vect_analyze_data_refs ===

test.c:127: note: get vectype with 4 units of type int
test.c:127: note: vectype: vector(4) int
test.c:127: note: get vectype with 4 units of type int
test.c:127: note: vectype: vector(4) int
test.c:127: note: === vect_analyze_scalar_cycles ===
test.c:127: note: Analyze phi: j_50 = PHI <j_31(13), 0(11)>

test.c:127: note: Access function of PHI: {0, +, 1}_3
test.c:127: note: step: 1,  init: 0
test.c:127: note: Detected induction.
test.c:127: note: Analyze phi: cdf_52 = PHI <cdf_27(13), 0.0(11)>

test.c:127: note: Access function of PHI: {0.0, +, D.7103_26}_3
test.c:127: note: step: D.7103_26,  init: 0.0
test.c:127: note: step unknown.
test.c:127: note: Analyze phi: .MEM_54 = PHI <.MEM_39(13), .MEM_37(11)>

test.c:127: note: Analyze phi: ivtmp.338_40 = PHI <ivtmp.338_35(13), 256(11)>

test.c:127: note: Access function of PHI: {256, +, 4294967295}_3
test.c:127: note: step: 4294967295,  init: 256
test.c:127: note: Detected induction.
test.c:127: note: Analyze phi: cdf_52 = PHI <cdf_27(13), 0.0(11)>

test.c:127: note: reduction used in loop.
test.c:127: note: Unknown def-use cycle pattern.
test.c:127: note: === vect_pattern_recog ===
test.c:127: note: vect_is_simple_use: operand D.7102_25
test.c:127: note: def_stmt: D.7102_25 = (float) D.7101_24;

test.c:127: note: type of def: 3.
test.c:127: note: vect_is_simple_use: operand D.7104_28
test.c:127: note: def_stmt: D.7104_28 = (double) cdf_27;

test.c:127: note: type of def: 3.
test.c:127: note: === vect_mark_stmts_to_be_vectorized ===
test.c:127: note: init: phi relevant? j_50 = PHI <j_31(13), 0(11)>

test.c:127: note: init: phi relevant? cdf_52 = PHI <cdf_27(13), 0.0(11)>

test.c:127: note: init: phi relevant? .MEM_54 = PHI <.MEM_39(13), .MEM_37(11)>

test.c:127: note: init: phi relevant? ivtmp.338_40 = PHI <ivtmp.338_35(13), 256(11)>

test.c:127: note: init: stmt relevant? D.7101_24 = a9_histo[j_50];

test.c:127: note: init: stmt relevant? D.7102_25 = (float) D.7101_24;

test.c:127: note: init: stmt relevant? D.7103_26 = D.7102_25 * 5.9604644775390625e-8;

test.c:127: note: init: stmt relevant? cdf_27 = D.7103_26 + cdf_52;

test.c:127: note: init: stmt relevant? D.7104_28 = (double) cdf_27;

test.c:127: note: init: stmt relevant? D.7105_29 = D.7104_28 * 2.55e+2;

test.c:127: note: init: stmt relevant? D.7106_30 = (int) D.7105_29;

test.c:127: note: init: stmt relevant? a9_gray_level_mapping[j_50] = D.7106_30;

test.c:127: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:127: note: mark relevant 4, live 0.
test.c:127: note: init: stmt relevant? j_31 = j_50 + 1;

test.c:127: note: init: stmt relevant? ivtmp.338_35 = ivtmp.338_40 - 1;

test.c:127: note: init: stmt relevant? if (ivtmp.338_35 != 0)

test.c:127: note: worklist: examine stmt: a9_gray_level_mapping[j_50] = D.7106_30;

test.c:127: note: vect_is_simple_use: operand D.7106_30
test.c:127: note: def_stmt: D.7106_30 = (int) D.7105_29;

test.c:127: note: type of def: 3.
test.c:127: note: mark relevant 4, live 0.
test.c:127: note: worklist: examine stmt: D.7106_30 = (int) D.7105_29;

test.c:127: note: vect_is_simple_use: operand D.7105_29
test.c:127: note: def_stmt: D.7105_29 = D.7104_28 * 2.55e+2;

test.c:127: note: type of def: 3.
test.c:127: note: mark relevant 4, live 0.
test.c:127: note: worklist: examine stmt: D.7105_29 = D.7104_28 * 2.55e+2;

test.c:127: note: vect_is_simple_use: operand D.7104_28
test.c:127: note: def_stmt: D.7104_28 = (double) cdf_27;

test.c:127: note: type of def: 3.
test.c:127: note: mark relevant 4, live 0.
test.c:127: note: worklist: examine stmt: D.7104_28 = (double) cdf_27;

test.c:127: note: vect_is_simple_use: operand cdf_27
test.c:127: note: def_stmt: cdf_27 = D.7103_26 + cdf_52;

test.c:127: note: type of def: 3.
test.c:127: note: mark relevant 4, live 0.
test.c:127: note: worklist: examine stmt: cdf_27 = D.7103_26 + cdf_52;

test.c:127: note: vect_is_simple_use: operand D.7103_26
test.c:127: note: def_stmt: D.7103_26 = D.7102_25 * 5.9604644775390625e-8;

test.c:127: note: type of def: 3.
test.c:127: note: mark relevant 4, live 0.
test.c:127: note: vect_is_simple_use: operand cdf_52
test.c:127: note: def_stmt: cdf_52 = PHI <cdf_27(13), 0.0(11)>

test.c:127: note: Unsupported pattern.
test.c:127: note: not vectorized: unsupported use in stmt.
test.c:127: note: unexpected pattern.
test.c:127: note: ***** Re-trying analysis with vector size 8

test.c:127: note: === vect_analyze_loop_form ===
test.c:127: note: === get_loop_niters ===
test.c:127: note: ==> get_loop_niters:256
test.c:127: note: === vect_analyze_data_refs ===

test.c:127: note: get vectype with 2 units of type int
test.c:127: note: vectype: vector(2) int
test.c:127: note: get vectype with 2 units of type int
test.c:127: note: vectype: vector(2) int
test.c:127: note: === vect_analyze_scalar_cycles ===
test.c:127: note: Analyze phi: j_50 = PHI <j_31(13), 0(11)>

test.c:127: note: Access function of PHI: {0, +, 1}_3
test.c:127: note: step: 1,  init: 0
test.c:127: note: Detected induction.
test.c:127: note: Analyze phi: cdf_52 = PHI <cdf_27(13), 0.0(11)>

test.c:127: note: Access function of PHI: {0.0, +, D.7103_26}_3
test.c:127: note: step: D.7103_26,  init: 0.0
test.c:127: note: step unknown.
test.c:127: note: Analyze phi: .MEM_54 = PHI <.MEM_39(13), .MEM_37(11)>

test.c:127: note: Analyze phi: ivtmp.338_40 = PHI <ivtmp.338_35(13), 256(11)>

test.c:127: note: Access function of PHI: {256, +, 4294967295}_3
test.c:127: note: step: 4294967295,  init: 256
test.c:127: note: Detected induction.
test.c:127: note: Analyze phi: cdf_52 = PHI <cdf_27(13), 0.0(11)>

test.c:127: note: reduction used in loop.
test.c:127: note: Unknown def-use cycle pattern.
test.c:127: note: === vect_pattern_recog ===
test.c:127: note: vect_is_simple_use: operand D.7102_25
test.c:127: note: def_stmt: D.7102_25 = (float) D.7101_24;

test.c:127: note: type of def: 3.
test.c:127: note: vect_is_simple_use: operand D.7104_28
test.c:127: note: def_stmt: D.7104_28 = (double) cdf_27;

test.c:127: note: type of def: 3.
test.c:127: note: === vect_mark_stmts_to_be_vectorized ===
test.c:127: note: init: phi relevant? j_50 = PHI <j_31(13), 0(11)>

test.c:127: note: init: phi relevant? cdf_52 = PHI <cdf_27(13), 0.0(11)>

test.c:127: note: init: phi relevant? .MEM_54 = PHI <.MEM_39(13), .MEM_37(11)>

test.c:127: note: init: phi relevant? ivtmp.338_40 = PHI <ivtmp.338_35(13), 256(11)>

test.c:127: note: init: stmt relevant? D.7101_24 = a9_histo[j_50];

test.c:127: note: init: stmt relevant? D.7102_25 = (float) D.7101_24;

test.c:127: note: init: stmt relevant? D.7103_26 = D.7102_25 * 5.9604644775390625e-8;

test.c:127: note: init: stmt relevant? cdf_27 = D.7103_26 + cdf_52;

test.c:127: note: init: stmt relevant? D.7104_28 = (double) cdf_27;

test.c:127: note: init: stmt relevant? D.7105_29 = D.7104_28 * 2.55e+2;

test.c:127: note: init: stmt relevant? D.7106_30 = (int) D.7105_29;

test.c:127: note: init: stmt relevant? a9_gray_level_mapping[j_50] = D.7106_30;

test.c:127: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:127: note: mark relevant 4, live 0.
test.c:127: note: init: stmt relevant? j_31 = j_50 + 1;

test.c:127: note: init: stmt relevant? ivtmp.338_35 = ivtmp.338_40 - 1;

test.c:127: note: init: stmt relevant? if (ivtmp.338_35 != 0)

test.c:127: note: worklist: examine stmt: a9_gray_level_mapping[j_50] = D.7106_30;

test.c:127: note: vect_is_simple_use: operand D.7106_30
test.c:127: note: def_stmt: D.7106_30 = (int) D.7105_29;

test.c:127: note: type of def: 3.
test.c:127: note: mark relevant 4, live 0.
test.c:127: note: worklist: examine stmt: D.7106_30 = (int) D.7105_29;

test.c:127: note: vect_is_simple_use: operand D.7105_29
test.c:127: note: def_stmt: D.7105_29 = D.7104_28 * 2.55e+2;

test.c:127: note: type of def: 3.
test.c:127: note: mark relevant 4, live 0.
test.c:127: note: worklist: examine stmt: D.7105_29 = D.7104_28 * 2.55e+2;

test.c:127: note: vect_is_simple_use: operand D.7104_28
test.c:127: note: def_stmt: D.7104_28 = (double) cdf_27;

test.c:127: note: type of def: 3.
test.c:127: note: mark relevant 4, live 0.
test.c:127: note: worklist: examine stmt: D.7104_28 = (double) cdf_27;

test.c:127: note: vect_is_simple_use: operand cdf_27
test.c:127: note: def_stmt: cdf_27 = D.7103_26 + cdf_52;

test.c:127: note: type of def: 3.
test.c:127: note: mark relevant 4, live 0.
test.c:127: note: worklist: examine stmt: cdf_27 = D.7103_26 + cdf_52;

test.c:127: note: vect_is_simple_use: operand D.7103_26
test.c:127: note: def_stmt: D.7103_26 = D.7102_25 * 5.9604644775390625e-8;

test.c:127: note: type of def: 3.
test.c:127: note: mark relevant 4, live 0.
test.c:127: note: vect_is_simple_use: operand cdf_52
test.c:127: note: def_stmt: cdf_52 = PHI <cdf_27(13), 0.0(11)>

test.c:127: note: Unsupported pattern.
test.c:127: note: not vectorized: unsupported use in stmt.
test.c:127: note: unexpected pattern.
test.c:115: note: ===== analyze_loop_nest =====
test.c:115: note: === vect_analyze_loop_form ===
test.c:115: note: ===== analyze_loop_nest_1 =====
test.c:115: note: === vect_analyze_loop_form ===
test.c:115: note: not vectorized: control flow in loop.
test.c:115: note: bad inner-loop form.
test.c:115: note: not vectorized: Bad inner loop.
test.c:115: note: bad loop form.
test.c:116: note: ===== analyze_loop_nest =====
test.c:116: note: === vect_analyze_loop_form ===
test.c:116: note: not vectorized: control flow in loop.
test.c:116: note: bad loop form.
test.c:109: note: vectorized 0 loops in function.

test.c:139: note: ===== analyze_loop_nest =====
test.c:139: note: === vect_analyze_loop_form ===
test.c:139: note: not vectorized: multiple nested loops.
test.c:139: note: bad loop form.
test.c:170: note: ===== analyze_loop_nest =====
test.c:170: note: === vect_analyze_loop_form ===
test.c:170: note: ===== analyze_loop_nest_1 =====
test.c:170: note: === vect_analyze_loop_form ===
test.c:170: note: === get_loop_niters ===
test.c:170: note: ==> get_loop_niters:4096
test.c:170: note: Considering outer-loop vectorization.
test.c:170: note: === get_loop_niters ===
test.c:170: note: ==> get_loop_niters:4096
test.c:170: note: === vect_analyze_data_refs ===

test.c:170: note: analyze in outer-loop: *(image_19(D) + (unsigned int) ((unsigned int) i_131 * 16384))
test.c:170: note: 	outer base_address: image_19(D)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:170: note: get vectype with 4 units of type int
test.c:170: note: vectype: vector(4) int
test.c:170: note: not vectorized: data ref analysis failed D.7090_83 = *D.7089_82;

test.c:170: note: bad data references.
test.c:170: note: ***** Re-trying analysis with vector size 8

test.c:170: note: === vect_analyze_loop_form ===
test.c:170: note: ===== analyze_loop_nest_1 =====
test.c:170: note: === vect_analyze_loop_form ===
test.c:170: note: === get_loop_niters ===
test.c:170: note: ==> get_loop_niters:4096
test.c:170: note: Considering outer-loop vectorization.
test.c:170: note: === get_loop_niters ===
test.c:170: note: ==> get_loop_niters:4096
test.c:170: note: === vect_analyze_data_refs ===

test.c:170: note: analyze in outer-loop: *(image_19(D) + (unsigned int) ((unsigned int) i_131 * 16384))
test.c:170: note: 	outer base_address: image_19(D)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:170: note: get vectype with 2 units of type int
test.c:170: note: vectype: vector(2) int
test.c:170: note: not vectorized: data ref analysis failed D.7090_83 = *D.7089_82;

test.c:170: note: bad data references.
test.c:171: note: ===== analyze_loop_nest =====
test.c:171: note: === vect_analyze_loop_form ===
test.c:171: note: === get_loop_niters ===
test.c:171: note: ==> get_loop_niters:4096
test.c:171: note: === vect_analyze_data_refs ===

test.c:171: note: get vectype with 4 units of type int
test.c:171: note: vectype: vector(4) int
test.c:171: note: not vectorized: data ref analysis failed D.7090_83 = *D.7089_82;

test.c:171: note: bad data references.
test.c:171: note: ***** Re-trying analysis with vector size 8

test.c:171: note: === vect_analyze_loop_form ===
test.c:171: note: === get_loop_niters ===
test.c:171: note: ==> get_loop_niters:4096
test.c:171: note: === vect_analyze_data_refs ===

test.c:171: note: get vectype with 2 units of type int
test.c:171: note: vectype: vector(2) int
test.c:171: note: not vectorized: data ref analysis failed D.7090_83 = *D.7089_82;

test.c:171: note: bad data references.
test.c:163: note: ===== analyze_loop_nest =====
test.c:163: note: === vect_analyze_loop_form ===
test.c:163: note: === get_loop_niters ===
test.c:163: note: ==> get_loop_niters:256
test.c:163: note: === vect_analyze_data_refs ===

test.c:163: note: get vectype with 4 units of type int
test.c:163: note: vectype: vector(4) int
test.c:163: note: get vectype with 4 units of type int
test.c:163: note: vectype: vector(4) int
test.c:163: note: === vect_analyze_scalar_cycles ===
test.c:163: note: Analyze phi: i_130 = PHI <i_66(20), 0(17)>

test.c:163: note: Access function of PHI: {0, +, 1}_7
test.c:163: note: step: 1,  init: 0
test.c:163: note: Detected induction.
test.c:163: note: Analyze phi: cdf_135 = PHI <cdf_58(20), 0.0(17)>

test.c:163: note: Access function of PHI: {0.0, +, D.7081_57}_7
test.c:163: note: step: D.7081_57,  init: 0.0
test.c:163: note: step unknown.
test.c:163: note: Analyze phi: .MEM_140 = PHI <.MEM_100(20), .MEM_99(17)>

test.c:163: note: Analyze phi: ivtmp.461_208 = PHI <ivtmp.461_207(20), 256(17)>

test.c:163: note: Access function of PHI: {256, +, 4294967295}_7
test.c:163: note: step: 4294967295,  init: 256
test.c:163: note: Detected induction.
test.c:163: note: Analyze phi: cdf_135 = PHI <cdf_58(20), 0.0(17)>

test.c:163: note: reduction used in loop.
test.c:163: note: Unknown def-use cycle pattern.
test.c:163: note: === vect_pattern_recog ===
test.c:163: note: vect_is_simple_use: operand i.3_52
test.c:163: note: def_stmt: i.3_52 = (unsigned int) i_130;

test.c:163: note: type of def: 3.
test.c:163: note: vect_is_simple_use: operand D.7080_56
test.c:163: note: def_stmt: D.7080_56 = (float) D.7079_55;

test.c:163: note: type of def: 3.
test.c:163: note: vect_is_simple_use: operand D.7083_63
test.c:163: note: def_stmt: D.7083_63 = (double) cdf_58;

test.c:163: note: type of def: 3.
test.c:163: note: === vect_mark_stmts_to_be_vectorized ===
test.c:163: note: init: phi relevant? i_130 = PHI <i_66(20), 0(17)>

test.c:163: note: init: phi relevant? cdf_135 = PHI <cdf_58(20), 0.0(17)>

test.c:163: note: init: phi relevant? .MEM_140 = PHI <.MEM_100(20), .MEM_99(17)>

test.c:163: note: init: phi relevant? ivtmp.461_208 = PHI <ivtmp.461_207(20), 256(17)>

test.c:163: note: init: stmt relevant? i.3_52 = (unsigned int) i_130;

test.c:163: note: init: stmt relevant? D.7072_53 = i.3_52 * 4;

test.c:163: note: init: stmt relevant? D.7073_54 = histogram_28(D) + D.7072_53;

test.c:163: note: init: stmt relevant? D.7079_55 = *D.7073_54;

test.c:163: note: init: stmt relevant? D.7080_56 = (float) D.7079_55;

test.c:163: note: init: stmt relevant? D.7081_57 = D.7080_56 * 5.9604644775390625e-8;

test.c:163: note: init: stmt relevant? cdf_58 = D.7081_57 + cdf_135;

test.c:163: note: init: stmt relevant? D.7082_62 = gray_level_mapping_61(D) + D.7072_53;

test.c:163: note: init: stmt relevant? D.7083_63 = (double) cdf_58;

test.c:163: note: init: stmt relevant? D.7084_64 = D.7083_63 * 2.55e+2;

test.c:163: note: init: stmt relevant? D.7085_65 = (int) D.7084_64;

test.c:163: note: init: stmt relevant? *D.7082_62 = D.7085_65;

test.c:163: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:163: note: mark relevant 4, live 0.
test.c:163: note: init: stmt relevant? i_66 = i_130 + 1;

test.c:163: note: init: stmt relevant? ivtmp.461_207 = ivtmp.461_208 - 1;

test.c:163: note: init: stmt relevant? if (ivtmp.461_207 != 0)

test.c:163: note: worklist: examine stmt: *D.7082_62 = D.7085_65;

test.c:163: note: vect_is_simple_use: operand D.7085_65
test.c:163: note: def_stmt: D.7085_65 = (int) D.7084_64;

test.c:163: note: type of def: 3.
test.c:163: note: mark relevant 4, live 0.
test.c:163: note: worklist: examine stmt: D.7085_65 = (int) D.7084_64;

test.c:163: note: vect_is_simple_use: operand D.7084_64
test.c:163: note: def_stmt: D.7084_64 = D.7083_63 * 2.55e+2;

test.c:163: note: type of def: 3.
test.c:163: note: mark relevant 4, live 0.
test.c:163: note: worklist: examine stmt: D.7084_64 = D.7083_63 * 2.55e+2;

test.c:163: note: vect_is_simple_use: operand D.7083_63
test.c:163: note: def_stmt: D.7083_63 = (double) cdf_58;

test.c:163: note: type of def: 3.
test.c:163: note: mark relevant 4, live 0.
test.c:163: note: worklist: examine stmt: D.7083_63 = (double) cdf_58;

test.c:163: note: vect_is_simple_use: operand cdf_58
test.c:163: note: def_stmt: cdf_58 = D.7081_57 + cdf_135;

test.c:163: note: type of def: 3.
test.c:163: note: mark relevant 4, live 0.
test.c:163: note: worklist: examine stmt: cdf_58 = D.7081_57 + cdf_135;

test.c:163: note: vect_is_simple_use: operand D.7081_57
test.c:163: note: def_stmt: D.7081_57 = D.7080_56 * 5.9604644775390625e-8;

test.c:163: note: type of def: 3.
test.c:163: note: mark relevant 4, live 0.
test.c:163: note: vect_is_simple_use: operand cdf_135
test.c:163: note: def_stmt: cdf_135 = PHI <cdf_58(20), 0.0(17)>

test.c:163: note: Unsupported pattern.
test.c:163: note: not vectorized: unsupported use in stmt.
test.c:163: note: unexpected pattern.
test.c:163: note: ***** Re-trying analysis with vector size 8

test.c:163: note: === vect_analyze_loop_form ===
test.c:163: note: === get_loop_niters ===
test.c:163: note: ==> get_loop_niters:256
test.c:163: note: === vect_analyze_data_refs ===

test.c:163: note: get vectype with 2 units of type int
test.c:163: note: vectype: vector(2) int
test.c:163: note: get vectype with 2 units of type int
test.c:163: note: vectype: vector(2) int
test.c:163: note: === vect_analyze_scalar_cycles ===
test.c:163: note: Analyze phi: i_130 = PHI <i_66(20), 0(17)>

test.c:163: note: Access function of PHI: {0, +, 1}_7
test.c:163: note: step: 1,  init: 0
test.c:163: note: Detected induction.
test.c:163: note: Analyze phi: cdf_135 = PHI <cdf_58(20), 0.0(17)>

test.c:163: note: Access function of PHI: {0.0, +, D.7081_57}_7
test.c:163: note: step: D.7081_57,  init: 0.0
test.c:163: note: step unknown.
test.c:163: note: Analyze phi: .MEM_140 = PHI <.MEM_100(20), .MEM_99(17)>

test.c:163: note: Analyze phi: ivtmp.461_208 = PHI <ivtmp.461_207(20), 256(17)>

test.c:163: note: Access function of PHI: {256, +, 4294967295}_7
test.c:163: note: step: 4294967295,  init: 256
test.c:163: note: Detected induction.
test.c:163: note: Analyze phi: cdf_135 = PHI <cdf_58(20), 0.0(17)>

test.c:163: note: reduction used in loop.
test.c:163: note: Unknown def-use cycle pattern.
test.c:163: note: === vect_pattern_recog ===
test.c:163: note: vect_is_simple_use: operand i.3_52
test.c:163: note: def_stmt: i.3_52 = (unsigned int) i_130;

test.c:163: note: type of def: 3.
test.c:163: note: vect_is_simple_use: operand D.7080_56
test.c:163: note: def_stmt: D.7080_56 = (float) D.7079_55;

test.c:163: note: type of def: 3.
test.c:163: note: vect_is_simple_use: operand D.7083_63
test.c:163: note: def_stmt: D.7083_63 = (double) cdf_58;

test.c:163: note: type of def: 3.
test.c:163: note: === vect_mark_stmts_to_be_vectorized ===
test.c:163: note: init: phi relevant? i_130 = PHI <i_66(20), 0(17)>

test.c:163: note: init: phi relevant? cdf_135 = PHI <cdf_58(20), 0.0(17)>

test.c:163: note: init: phi relevant? .MEM_140 = PHI <.MEM_100(20), .MEM_99(17)>

test.c:163: note: init: phi relevant? ivtmp.461_208 = PHI <ivtmp.461_207(20), 256(17)>

test.c:163: note: init: stmt relevant? i.3_52 = (unsigned int) i_130;

test.c:163: note: init: stmt relevant? D.7072_53 = i.3_52 * 4;

test.c:163: note: init: stmt relevant? D.7073_54 = histogram_28(D) + D.7072_53;

test.c:163: note: init: stmt relevant? D.7079_55 = *D.7073_54;

test.c:163: note: init: stmt relevant? D.7080_56 = (float) D.7079_55;

test.c:163: note: init: stmt relevant? D.7081_57 = D.7080_56 * 5.9604644775390625e-8;

test.c:163: note: init: stmt relevant? cdf_58 = D.7081_57 + cdf_135;

test.c:163: note: init: stmt relevant? D.7082_62 = gray_level_mapping_61(D) + D.7072_53;

test.c:163: note: init: stmt relevant? D.7083_63 = (double) cdf_58;

test.c:163: note: init: stmt relevant? D.7084_64 = D.7083_63 * 2.55e+2;

test.c:163: note: init: stmt relevant? D.7085_65 = (int) D.7084_64;

test.c:163: note: init: stmt relevant? *D.7082_62 = D.7085_65;

test.c:163: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:163: note: mark relevant 4, live 0.
test.c:163: note: init: stmt relevant? i_66 = i_130 + 1;

test.c:163: note: init: stmt relevant? ivtmp.461_207 = ivtmp.461_208 - 1;

test.c:163: note: init: stmt relevant? if (ivtmp.461_207 != 0)

test.c:163: note: worklist: examine stmt: *D.7082_62 = D.7085_65;

test.c:163: note: vect_is_simple_use: operand D.7085_65
test.c:163: note: def_stmt: D.7085_65 = (int) D.7084_64;

test.c:163: note: type of def: 3.
test.c:163: note: mark relevant 4, live 0.
test.c:163: note: worklist: examine stmt: D.7085_65 = (int) D.7084_64;

test.c:163: note: vect_is_simple_use: operand D.7084_64
test.c:163: note: def_stmt: D.7084_64 = D.7083_63 * 2.55e+2;

test.c:163: note: type of def: 3.
test.c:163: note: mark relevant 4, live 0.
test.c:163: note: worklist: examine stmt: D.7084_64 = D.7083_63 * 2.55e+2;

test.c:163: note: vect_is_simple_use: operand D.7083_63
test.c:163: note: def_stmt: D.7083_63 = (double) cdf_58;

test.c:163: note: type of def: 3.
test.c:163: note: mark relevant 4, live 0.
test.c:163: note: worklist: examine stmt: D.7083_63 = (double) cdf_58;

test.c:163: note: vect_is_simple_use: operand cdf_58
test.c:163: note: def_stmt: cdf_58 = D.7081_57 + cdf_135;

test.c:163: note: type of def: 3.
test.c:163: note: mark relevant 4, live 0.
test.c:163: note: worklist: examine stmt: cdf_58 = D.7081_57 + cdf_135;

test.c:163: note: vect_is_simple_use: operand D.7081_57
test.c:163: note: def_stmt: D.7081_57 = D.7080_56 * 5.9604644775390625e-8;

test.c:163: note: type of def: 3.
test.c:163: note: mark relevant 4, live 0.
test.c:163: note: vect_is_simple_use: operand cdf_135
test.c:163: note: def_stmt: cdf_135 = PHI <cdf_58(20), 0.0(17)>

test.c:163: note: Unsupported pattern.
test.c:163: note: not vectorized: unsupported use in stmt.
test.c:163: note: unexpected pattern.
test.c:152: note: ===== analyze_loop_nest =====
test.c:152: note: === vect_analyze_loop_form ===
test.c:152: note: ===== analyze_loop_nest_1 =====
test.c:152: note: === vect_analyze_loop_form ===
test.c:152: note: === get_loop_niters ===
test.c:152: note: ==> get_loop_niters:4096
test.c:152: note: Considering outer-loop vectorization.
test.c:152: note: === get_loop_niters ===
test.c:152: note: ==> get_loop_niters:4096
test.c:152: note: === vect_analyze_data_refs ===

test.c:152: note: analyze in outer-loop: *(image_19(D) + (unsigned int) ((unsigned int) i_129 * 16384))
test.c:152: note: 	outer base_address: image_19(D)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:152: note: get vectype with 4 units of type int
test.c:152: note: vectype: vector(4) int
test.c:152: note: not vectorized: data ref analysis failed D.7077_45 = *D.7076_44;

test.c:152: note: bad data references.
test.c:152: note: ***** Re-trying analysis with vector size 8

test.c:152: note: === vect_analyze_loop_form ===
test.c:152: note: ===== analyze_loop_nest_1 =====
test.c:152: note: === vect_analyze_loop_form ===
test.c:152: note: === get_loop_niters ===
test.c:152: note: ==> get_loop_niters:4096
test.c:152: note: Considering outer-loop vectorization.
test.c:152: note: === get_loop_niters ===
test.c:152: note: ==> get_loop_niters:4096
test.c:152: note: === vect_analyze_data_refs ===

test.c:152: note: analyze in outer-loop: *(image_19(D) + (unsigned int) ((unsigned int) i_129 * 16384))
test.c:152: note: 	outer base_address: image_19(D)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:152: note: get vectype with 2 units of type int
test.c:152: note: vectype: vector(2) int
test.c:152: note: not vectorized: data ref analysis failed D.7077_45 = *D.7076_44;

test.c:152: note: bad data references.
test.c:153: note: ===== analyze_loop_nest =====
test.c:153: note: === vect_analyze_loop_form ===
test.c:153: note: === get_loop_niters ===
test.c:153: note: ==> get_loop_niters:4096
test.c:153: note: === vect_analyze_data_refs ===

test.c:153: note: get vectype with 4 units of type int
test.c:153: note: vectype: vector(4) int
test.c:153: note: not vectorized: data ref analysis failed D.7077_45 = *D.7076_44;

test.c:153: note: bad data references.
test.c:153: note: ***** Re-trying analysis with vector size 8

test.c:153: note: === vect_analyze_loop_form ===
test.c:153: note: === get_loop_niters ===
test.c:153: note: ==> get_loop_niters:4096
test.c:153: note: === vect_analyze_data_refs ===

test.c:153: note: get vectype with 2 units of type int
test.c:153: note: vectype: vector(2) int
test.c:153: note: not vectorized: data ref analysis failed D.7077_45 = *D.7076_44;

test.c:153: note: bad data references.
test.c:148: note: ===== analyze_loop_nest =====
test.c:148: note: === vect_analyze_loop_form ===
test.c:148: note: === get_loop_niters ===
test.c:148: note: ==> get_loop_niters:256
test.c:148: note: === vect_analyze_data_refs ===

test.c:148: note: get vectype with 4 units of type int
test.c:148: note: vectype: vector(4) int
test.c:148: note: === vect_analyze_scalar_cycles ===
test.c:148: note: Analyze phi: i_128 = PHI <i_30(11), 0(8)>

test.c:148: note: Access function of PHI: {0, +, 1}_4
test.c:148: note: step: 1,  init: 0
test.c:148: note: Detected induction.
test.c:148: note: Analyze phi: .MEM_138 = PHI <.MEM_98(11), .MEM_97(8)>

test.c:148: note: Analyze phi: ivtmp.464_202 = PHI <ivtmp.464_200(11), 256(8)>

test.c:148: note: Access function of PHI: {256, +, 4294967295}_4
test.c:148: note: step: 4294967295,  init: 256
test.c:148: note: Detected induction.
test.c:148: note: === vect_pattern_recog ===
test.c:148: note: vect_is_simple_use: operand i.3_26
test.c:148: note: def_stmt: i.3_26 = (unsigned int) i_128;

test.c:148: note: type of def: 3.
test.c:148: note: === vect_mark_stmts_to_be_vectorized ===
test.c:148: note: init: phi relevant? i_128 = PHI <i_30(11), 0(8)>

test.c:148: note: init: phi relevant? .MEM_138 = PHI <.MEM_98(11), .MEM_97(8)>

test.c:148: note: init: phi relevant? ivtmp.464_202 = PHI <ivtmp.464_200(11), 256(8)>

test.c:148: note: init: stmt relevant? i.3_26 = (unsigned int) i_128;

test.c:148: note: init: stmt relevant? D.7072_27 = i.3_26 * 4;

test.c:148: note: init: stmt relevant? D.7073_29 = histogram_28(D) + D.7072_27;

test.c:148: note: init: stmt relevant? *D.7073_29 = 0;

test.c:148: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:148: note: mark relevant 4, live 0.
test.c:148: note: init: stmt relevant? i_30 = i_128 + 1;

test.c:148: note: init: stmt relevant? ivtmp.464_200 = ivtmp.464_202 - 1;

test.c:148: note: init: stmt relevant? if (ivtmp.464_200 != 0)

test.c:148: note: worklist: examine stmt: *D.7073_29 = 0;

test.c:148: note: === vect_analyze_dependences ===
test.c:148: note: === vect_determine_vectorization_factor ===
test.c:148: note: ==> examining phi: i_128 = PHI <i_30(11), 0(8)>

test.c:148: note: ==> examining phi: .MEM_138 = PHI <.MEM_98(11), .MEM_97(8)>

test.c:148: note: ==> examining phi: ivtmp.464_202 = PHI <ivtmp.464_200(11), 256(8)>

test.c:148: note: ==> examining statement: i.3_26 = (unsigned int) i_128;

test.c:148: note: skip.
test.c:148: note: ==> examining statement: D.7072_27 = i.3_26 * 4;

test.c:148: note: skip.
test.c:148: note: ==> examining statement: D.7073_29 = histogram_28(D) + D.7072_27;

test.c:148: note: skip.
test.c:148: note: ==> examining statement: *D.7073_29 = 0;

test.c:148: note: get vectype for scalar type:  int
test.c:148: note: get vectype with 4 units of type int
test.c:148: note: vectype: vector(4) int
test.c:148: note: vectype: vector(4) int
test.c:148: note: nunits = 4
test.c:148: note: ==> examining statement: i_30 = i_128 + 1;

test.c:148: note: skip.
test.c:148: note: ==> examining statement: ivtmp.464_200 = ivtmp.464_202 - 1;

test.c:148: note: skip.
test.c:148: note: ==> examining statement: if (ivtmp.464_200 != 0)

test.c:148: note: skip.
test.c:148: note: vectorization factor = 4
test.c:148: note: === vect_analyze_data_refs_alignment ===
test.c:148: note: vect_compute_data_ref_alignment:
test.c:148: note: can't force alignment of ref: *D.7073_29
test.c:148: note: === vect_analyze_data_ref_accesses ===
test.c:148: note: === vect_prune_runtime_alias_test_list ===
test.c:148: note: === vect_enhance_data_refs_alignment ===
test.c:148: note: Unknown misalignment, is_packed = 0
test.c:148: note: vect_can_advance_ivs_p:
test.c:148: note: Analyze phi: i_128 = PHI <i_30(11), 0(8)>

test.c:148: note: Access function of PHI: {0, +, 1}_4
test.c:148: note: Analyze phi: .MEM_138 = PHI <.MEM_98(11), .MEM_97(8)>

test.c:148: note: virtual phi. skip.
test.c:148: note: Analyze phi: ivtmp.464_202 = PHI <ivtmp.464_200(11), 256(8)>

test.c:148: note: Access function of PHI: {256, +, 4294967295}_4
test.c:148: note: Alignment of access forced using peeling.
test.c:148: note: Peeling for alignment will be applied.
test.c:148: note: === vect_analyze_slp ===
test.c:148: note: === vect_make_slp_decision ===
test.c:148: note: === vect_detect_hybrid_slp ===
test.c:148: note: === vect_analyze_loop_operations ===
test.c:148: note: examining phi: i_128 = PHI <i_30(11), 0(8)>

test.c:148: note: examining phi: .MEM_138 = PHI <.MEM_98(11), .MEM_97(8)>

test.c:148: note: examining phi: ivtmp.464_202 = PHI <ivtmp.464_200(11), 256(8)>

test.c:148: note: ==> examining statement: i.3_26 = (unsigned int) i_128;

test.c:148: note: irrelevant.
test.c:148: note: ==> examining statement: D.7072_27 = i.3_26 * 4;

test.c:148: note: irrelevant.
test.c:148: note: ==> examining statement: D.7073_29 = histogram_28(D) + D.7072_27;

test.c:148: note: irrelevant.
test.c:148: note: ==> examining statement: *D.7073_29 = 0;

test.c:148: note: vect_is_simple_use: operand 0
test.c:148: note: vect_model_store_cost: aligned.
test.c:148: note: vect_model_store_cost: inside_cost = 1, outside_cost = 1 .
test.c:148: note: ==> examining statement: i_30 = i_128 + 1;

test.c:148: note: irrelevant.
test.c:148: note: ==> examining statement: ivtmp.464_200 = ivtmp.464_202 - 1;

test.c:148: note: irrelevant.
test.c:148: note: ==> examining statement: if (ivtmp.464_200 != 0)

test.c:148: note: irrelevant.
test.c:148: note: vectorization_factor = 4, niters = 256
test.c:148: note: === vect_update_slp_costs_according_to_vf ===
test.c:148: note: cost model disabled.
test.c:148: note: epilog loop required.
test.c:148: note: vect_can_advance_ivs_p:
test.c:148: note: Analyze phi: i_128 = PHI <i_30(11), 0(8)>

test.c:148: note: Access function of PHI: {0, +, 1}_4
test.c:148: note: Analyze phi: .MEM_138 = PHI <.MEM_98(11), .MEM_97(8)>

test.c:148: note: virtual phi. skip.
test.c:148: note: Analyze phi: ivtmp.464_202 = PHI <ivtmp.464_200(11), 256(8)>

test.c:148: note: Access function of PHI: {256, +, 4294967295}_4
test.c:148: note: === vec_transform_loop ===
test.c:148: note: === vect_do_peeling_for_alignment ===
test.c:148: note: created vect_p.470_195
test.c:148: note: niters for prolog loop: -(((unsigned int) vect_p.470_195 & 15) >> 2) & 3
test.c:148: note: Profitability threshold is 3 loop iterations.
test.c:148: note: === vect_update_inits_of_dr ===
test.c:148: note: === vect_do_peeling_for_loop_bound ===
test.c:148: note: vect_update_ivs_after_vectorizer: phi: i_128 = PHI <i_30(11), i_218(41)>

test.c:148: note: vect_update_ivs_after_vectorizer: phi: .MEM_138 = PHI <.MEM_98(11), .MEM_220(41)>

test.c:148: note: virtual phi. skip.
test.c:148: note: vect_update_ivs_after_vectorizer: phi: ivtmp.464_202 = PHI <ivtmp.464_200(11), ivtmp.464_221(41)>

test.c:148: note: ------>vectorizing phi: i_128 = PHI <i_30(11), i_218(46)>

test.c:148: note: ------>vectorizing phi: .MEM_138 = PHI <.MEM_98(11), .MEM_220(46)>

test.c:148: note: ------>vectorizing phi: ivtmp.464_202 = PHI <ivtmp.464_200(11), ivtmp.464_221(46)>

test.c:148: note: ------>vectorizing statement: i.3_26 = (unsigned int) i_128;

test.c:148: note: ------>vectorizing statement: D.7072_27 = i.3_26 * 4;

test.c:148: note: ------>vectorizing statement: D.7073_29 = histogram_28(D) + D.7072_27;

test.c:148: note: ------>vectorizing statement: *D.7073_29 = 0;

test.c:148: note: transform statement.
test.c:148: note: vect_is_simple_use: operand 0
test.c:148: note: transform store. ncopies = 1
test.c:148: note: vect_get_vec_def_for_operand: 0
test.c:148: note: vect_is_simple_use: operand 0
test.c:148: note: 
test.c:148: note: get vectype with 4 units of type int
test.c:148: note: vectype: vector(4) int
test.c:148: note: Create vector_cst. nunits = 4
test.c:148: note: created new init_stmt: vect_cst_.479_248 = { 0, 0, 0, 0 };

test.c:148: note: create vector_type-pointer variable to type: vector(4) int*histogram_28(D)
test.c:148: note: created vect_p.483_250
test.c:148: note: add new stmt: MEM[(int *)vect_p.480_251] = vect_cst_.479_248;

test.c:148: note: ------>vectorizing statement: i_30 = i_128 + 1;

test.c:148: note: ------>vectorizing statement: ivtmp.464_200 = ivtmp.464_202 - 1;

test.c:148: note: ------>vectorizing statement: vect_p.480_252 = vect_p.480_251 + 16;

test.c:148: note: ------>vectorizing statement: if (ivtmp.464_200 != 0)

test.c:148: note: LOOP VECTORIZED.
test.c:142: note: ===== analyze_loop_nest =====
test.c:142: note: === vect_analyze_loop_form ===
test.c:142: note: ===== analyze_loop_nest_1 =====
test.c:142: note: === vect_analyze_loop_form ===
test.c:142: note: === get_loop_niters ===
test.c:142: note: ==> get_loop_niters:4096
test.c:142: note: Considering outer-loop vectorization.
test.c:142: note: === get_loop_niters ===
test.c:142: note: ==> get_loop_niters:4096
test.c:142: note: === vect_analyze_data_refs ===

test.c:142: note: analyze in outer-loop: *(image_19(D) + (unsigned int) ((unsigned int) i_127 * 16384))
test.c:142: note: 	outer base_address: image_19(D)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:142: note: get vectype with 4 units of type int
test.c:142: note: vectype: vector(4) int
test.c:142: note: === vect_analyze_scalar_cycles ===
test.c:142: note: Analyze phi: .MEM_107 = PHI <.MEM_105(28), .MEM_97(6)>

test.c:142: note: Analyze phi: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: Access function of PHI: {0, +, 1}_2
test.c:142: note: step: 1,  init: 0
test.c:142: note: Detected induction.
test.c:142: note: Analyze phi: ivtmp.465_199 = PHI <4096(28), ivtmp.465_198(6)>

test.c:142: note: Access function of PHI: {4096, +, 4294967295}_2
test.c:142: note: step: 4294967295,  init: 4096
test.c:142: note: Detected induction.
test.c:142: note: === vect_analyze_scalar_cycles ===
test.c:142: note: Analyze phi: j_132 = PHI <j_23(3), 0(7)>

test.c:142: note: Access function of PHI: {0, +, 1}_3
test.c:142: note: step: 1,  init: 0
test.c:142: note: Detected induction.
test.c:142: note: Analyze phi: .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:142: note: Analyze phi: ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:142: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:142: note: step: 4294967295,  init: 4096
test.c:142: note: Detected induction.
test.c:142: note: === vect_pattern_recog ===
test.c:142: note: vect_is_simple_use: operand i_127
test.c:142: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: type of def: 4.
test.c:142: note: vect_is_simple_use: operand D.7066_17
test.c:142: note: def_stmt: D.7066_17 = (unsigned int) D.7065_16;

test.c:142: note: type of def: 3.
test.c:142: note: vect_is_simple_use: operand i_127
test.c:142: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: type of def: 4.
test.c:142: note: === vect_mark_stmts_to_be_vectorized ===
test.c:142: note: init: phi relevant? .MEM_107 = PHI <.MEM_105(28), .MEM_97(6)>

test.c:142: note: init: phi relevant? i_127 = PHI <0(28), i_24(6)>

test.c:142: note: init: phi relevant? ivtmp.465_199 = PHI <4096(28), ivtmp.465_198(6)>

test.c:142: note: init: stmt relevant? pretmp.449_189 = i_127 * 4096;

test.c:142: note: init: phi relevant? j_132 = PHI <j_23(3), 0(7)>

test.c:142: note: init: phi relevant? .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:142: note: init: phi relevant? ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:142: note: init: stmt relevant? D.7065_16 = j_132 + pretmp.449_189;

test.c:142: note: init: stmt relevant? D.7066_17 = (unsigned int) D.7065_16;

test.c:142: note: init: stmt relevant? D.7067_18 = D.7066_17 * 4;

test.c:142: note: init: stmt relevant? D.7068_20 = image_19(D) + D.7067_18;

test.c:142: note: init: stmt relevant? D.7069_21 = i_127 * j_132;

test.c:142: note: init: stmt relevant? D.7070_22 = D.7069_21 % 255;

test.c:142: note: init: stmt relevant? *D.7068_20 = D.7070_22;

test.c:142: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: init: stmt relevant? j_23 = j_132 + 1;

test.c:142: note: init: stmt relevant? ivtmp.466_196 = ivtmp.466_197 - 1;

test.c:142: note: init: stmt relevant? if (ivtmp.466_196 != 0)

test.c:142: note: init: stmt relevant? i_24 = i_127 + 1;

test.c:142: note: init: stmt relevant? ivtmp.465_198 = ivtmp.465_199 - 1;

test.c:142: note: init: stmt relevant? if (ivtmp.465_198 != 0)

test.c:142: note: worklist: examine stmt: *D.7068_20 = D.7070_22;

test.c:142: note: vect_is_simple_use: operand D.7070_22
test.c:142: note: def_stmt: D.7070_22 = D.7069_21 % 255;

test.c:142: note: type of def: 3.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: worklist: examine stmt: D.7070_22 = D.7069_21 % 255;

test.c:142: note: vect_is_simple_use: operand D.7069_21
test.c:142: note: def_stmt: D.7069_21 = i_127 * j_132;

test.c:142: note: type of def: 3.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: worklist: examine stmt: D.7069_21 = i_127 * j_132;

test.c:142: note: vect_is_simple_use: operand i_127
test.c:142: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: type of def: 4.
test.c:142: note: outer-loop def-stmt defining inner-loop stmt.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: vect_is_simple_use: operand j_132
test.c:142: note: def_stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:142: note: type of def: 4.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: worklist: examine stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:142: note: vect_is_simple_use: operand j_23
test.c:142: note: def_stmt: j_23 = j_132 + 1;

test.c:142: note: type of def: 3.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: vect_is_simple_use: operand 0
test.c:142: note: worklist: examine stmt: j_23 = j_132 + 1;

test.c:142: note: vect_is_simple_use: operand j_132
test.c:142: note: def_stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:142: note: type of def: 4.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: already marked relevant/live.
test.c:142: note: worklist: examine stmt: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: vect_is_simple_use: operand 0
test.c:142: note: vect_is_simple_use: operand i_24
test.c:142: note: def_stmt: i_24 = i_127 + 1;

test.c:142: note: type of def: 3.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: worklist: examine stmt: i_24 = i_127 + 1;

test.c:142: note: vect_is_simple_use: operand i_127
test.c:142: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: type of def: 4.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: already marked relevant/live.
test.c:142: note: === vect_analyze_dependences ===
test.c:142: note: === vect_determine_vectorization_factor ===
test.c:142: note: ==> examining phi: .MEM_107 = PHI <.MEM_105(28), .MEM_97(6)>

test.c:142: note: ==> examining phi: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 4 units of type int
test.c:142: note: vectype: vector(4) int
test.c:142: note: vectype: vector(4) int
test.c:142: note: nunits = 4
test.c:142: note: ==> examining phi: ivtmp.465_199 = PHI <4096(28), ivtmp.465_198(6)>

test.c:142: note: ==> examining statement: pretmp.449_189 = i_127 * 4096;

test.c:142: note: skip.
test.c:142: note: ==> examining phi: j_132 = PHI <j_23(3), 0(7)>

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 4 units of type int
test.c:142: note: vectype: vector(4) int
test.c:142: note: vectype: vector(4) int
test.c:142: note: nunits = 4
test.c:142: note: ==> examining phi: .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:142: note: ==> examining phi: ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:142: note: ==> examining statement: D.7065_16 = j_132 + pretmp.449_189;

test.c:142: note: skip.
test.c:142: note: ==> examining statement: D.7066_17 = (unsigned int) D.7065_16;

test.c:142: note: skip.
test.c:142: note: ==> examining statement: D.7067_18 = D.7066_17 * 4;

test.c:142: note: skip.
test.c:142: note: ==> examining statement: D.7068_20 = image_19(D) + D.7067_18;

test.c:142: note: skip.
test.c:142: note: ==> examining statement: D.7069_21 = i_127 * j_132;

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 4 units of type int
test.c:142: note: vectype: vector(4) int
test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 4 units of type int
test.c:142: note: vectype: vector(4) int
test.c:142: note: vectype: vector(4) int
test.c:142: note: nunits = 4
test.c:142: note: ==> examining statement: D.7070_22 = D.7069_21 % 255;

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 4 units of type int
test.c:142: note: vectype: vector(4) int
test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 4 units of type int
test.c:142: note: vectype: vector(4) int
test.c:142: note: vectype: vector(4) int
test.c:142: note: nunits = 4
test.c:142: note: ==> examining statement: *D.7068_20 = D.7070_22;

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 4 units of type int
test.c:142: note: vectype: vector(4) int
test.c:142: note: vectype: vector(4) int
test.c:142: note: nunits = 4
test.c:142: note: ==> examining statement: j_23 = j_132 + 1;

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 4 units of type int
test.c:142: note: vectype: vector(4) int
test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 4 units of type int
test.c:142: note: vectype: vector(4) int
test.c:142: note: vectype: vector(4) int
test.c:142: note: nunits = 4
test.c:142: note: ==> examining statement: ivtmp.466_196 = ivtmp.466_197 - 1;

test.c:142: note: skip.
test.c:142: note: ==> examining statement: if (ivtmp.466_196 != 0)

test.c:142: note: skip.
test.c:142: note: ==> examining statement: i_24 = i_127 + 1;

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 4 units of type int
test.c:142: note: vectype: vector(4) int
test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 4 units of type int
test.c:142: note: vectype: vector(4) int
test.c:142: note: vectype: vector(4) int
test.c:142: note: nunits = 4
test.c:142: note: ==> examining statement: ivtmp.465_198 = ivtmp.465_199 - 1;

test.c:142: note: skip.
test.c:142: note: ==> examining statement: if (ivtmp.465_198 != 0)

test.c:142: note: skip.
test.c:142: note: vectorization factor = 4
test.c:142: note: === vect_analyze_data_refs_alignment ===
test.c:142: note: vect_compute_data_ref_alignment:
test.c:142: note: inner step doesn't divide the vector-size.
test.c:142: note: Unknown alignment for access: *(image_19(D) + (unsigned int) ((unsigned int) i_127 * 16384))
test.c:142: note: === vect_analyze_data_ref_accesses ===
test.c:142: note: strided access in outer loop.
test.c:142: note: not vectorized: complicated access pattern.
test.c:142: note: bad data access.
test.c:142: note: ***** Re-trying analysis with vector size 8

test.c:142: note: === vect_analyze_loop_form ===
test.c:142: note: ===== analyze_loop_nest_1 =====
test.c:142: note: === vect_analyze_loop_form ===
test.c:142: note: === get_loop_niters ===
test.c:142: note: ==> get_loop_niters:4096
test.c:142: note: Considering outer-loop vectorization.
test.c:142: note: === get_loop_niters ===
test.c:142: note: ==> get_loop_niters:4096
test.c:142: note: === vect_analyze_data_refs ===

test.c:142: note: analyze in outer-loop: *(image_19(D) + (unsigned int) ((unsigned int) i_127 * 16384))
test.c:142: note: 	outer base_address: image_19(D)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:142: note: get vectype with 2 units of type int
test.c:142: note: vectype: vector(2) int
test.c:142: note: === vect_analyze_scalar_cycles ===
test.c:142: note: Analyze phi: .MEM_107 = PHI <.MEM_105(28), .MEM_97(6)>

test.c:142: note: Analyze phi: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: Access function of PHI: {0, +, 1}_2
test.c:142: note: step: 1,  init: 0
test.c:142: note: Detected induction.
test.c:142: note: Analyze phi: ivtmp.465_199 = PHI <4096(28), ivtmp.465_198(6)>

test.c:142: note: Access function of PHI: {4096, +, 4294967295}_2
test.c:142: note: step: 4294967295,  init: 4096
test.c:142: note: Detected induction.
test.c:142: note: === vect_analyze_scalar_cycles ===
test.c:142: note: Analyze phi: j_132 = PHI <j_23(3), 0(7)>

test.c:142: note: Access function of PHI: {0, +, 1}_3
test.c:142: note: step: 1,  init: 0
test.c:142: note: Detected induction.
test.c:142: note: Analyze phi: .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:142: note: Analyze phi: ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:142: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:142: note: step: 4294967295,  init: 4096
test.c:142: note: Detected induction.
test.c:142: note: === vect_pattern_recog ===
test.c:142: note: vect_is_simple_use: operand i_127
test.c:142: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: type of def: 4.
test.c:142: note: vect_is_simple_use: operand D.7066_17
test.c:142: note: def_stmt: D.7066_17 = (unsigned int) D.7065_16;

test.c:142: note: type of def: 3.
test.c:142: note: vect_is_simple_use: operand i_127
test.c:142: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: type of def: 4.
test.c:142: note: === vect_mark_stmts_to_be_vectorized ===
test.c:142: note: init: phi relevant? .MEM_107 = PHI <.MEM_105(28), .MEM_97(6)>

test.c:142: note: init: phi relevant? i_127 = PHI <0(28), i_24(6)>

test.c:142: note: init: phi relevant? ivtmp.465_199 = PHI <4096(28), ivtmp.465_198(6)>

test.c:142: note: init: stmt relevant? pretmp.449_189 = i_127 * 4096;

test.c:142: note: init: phi relevant? j_132 = PHI <j_23(3), 0(7)>

test.c:142: note: init: phi relevant? .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:142: note: init: phi relevant? ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:142: note: init: stmt relevant? D.7065_16 = j_132 + pretmp.449_189;

test.c:142: note: init: stmt relevant? D.7066_17 = (unsigned int) D.7065_16;

test.c:142: note: init: stmt relevant? D.7067_18 = D.7066_17 * 4;

test.c:142: note: init: stmt relevant? D.7068_20 = image_19(D) + D.7067_18;

test.c:142: note: init: stmt relevant? D.7069_21 = i_127 * j_132;

test.c:142: note: init: stmt relevant? D.7070_22 = D.7069_21 % 255;

test.c:142: note: init: stmt relevant? *D.7068_20 = D.7070_22;

test.c:142: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: init: stmt relevant? j_23 = j_132 + 1;

test.c:142: note: init: stmt relevant? ivtmp.466_196 = ivtmp.466_197 - 1;

test.c:142: note: init: stmt relevant? if (ivtmp.466_196 != 0)

test.c:142: note: init: stmt relevant? i_24 = i_127 + 1;

test.c:142: note: init: stmt relevant? ivtmp.465_198 = ivtmp.465_199 - 1;

test.c:142: note: init: stmt relevant? if (ivtmp.465_198 != 0)

test.c:142: note: worklist: examine stmt: *D.7068_20 = D.7070_22;

test.c:142: note: vect_is_simple_use: operand D.7070_22
test.c:142: note: def_stmt: D.7070_22 = D.7069_21 % 255;

test.c:142: note: type of def: 3.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: worklist: examine stmt: D.7070_22 = D.7069_21 % 255;

test.c:142: note: vect_is_simple_use: operand D.7069_21
test.c:142: note: def_stmt: D.7069_21 = i_127 * j_132;

test.c:142: note: type of def: 3.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: worklist: examine stmt: D.7069_21 = i_127 * j_132;

test.c:142: note: vect_is_simple_use: operand i_127
test.c:142: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: type of def: 4.
test.c:142: note: outer-loop def-stmt defining inner-loop stmt.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: vect_is_simple_use: operand j_132
test.c:142: note: def_stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:142: note: type of def: 4.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: worklist: examine stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:142: note: vect_is_simple_use: operand j_23
test.c:142: note: def_stmt: j_23 = j_132 + 1;

test.c:142: note: type of def: 3.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: vect_is_simple_use: operand 0
test.c:142: note: worklist: examine stmt: j_23 = j_132 + 1;

test.c:142: note: vect_is_simple_use: operand j_132
test.c:142: note: def_stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:142: note: type of def: 4.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: already marked relevant/live.
test.c:142: note: worklist: examine stmt: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: vect_is_simple_use: operand 0
test.c:142: note: vect_is_simple_use: operand i_24
test.c:142: note: def_stmt: i_24 = i_127 + 1;

test.c:142: note: type of def: 3.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: worklist: examine stmt: i_24 = i_127 + 1;

test.c:142: note: vect_is_simple_use: operand i_127
test.c:142: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: type of def: 4.
test.c:142: note: mark relevant 4, live 0.
test.c:142: note: already marked relevant/live.
test.c:142: note: === vect_analyze_dependences ===
test.c:142: note: === vect_determine_vectorization_factor ===
test.c:142: note: ==> examining phi: .MEM_107 = PHI <.MEM_105(28), .MEM_97(6)>

test.c:142: note: ==> examining phi: i_127 = PHI <0(28), i_24(6)>

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 2 units of type int
test.c:142: note: vectype: vector(2) int
test.c:142: note: vectype: vector(2) int
test.c:142: note: nunits = 2
test.c:142: note: ==> examining phi: ivtmp.465_199 = PHI <4096(28), ivtmp.465_198(6)>

test.c:142: note: ==> examining statement: pretmp.449_189 = i_127 * 4096;

test.c:142: note: skip.
test.c:142: note: ==> examining phi: j_132 = PHI <j_23(3), 0(7)>

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 2 units of type int
test.c:142: note: vectype: vector(2) int
test.c:142: note: vectype: vector(2) int
test.c:142: note: nunits = 2
test.c:142: note: ==> examining phi: .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:142: note: ==> examining phi: ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:142: note: ==> examining statement: D.7065_16 = j_132 + pretmp.449_189;

test.c:142: note: skip.
test.c:142: note: ==> examining statement: D.7066_17 = (unsigned int) D.7065_16;

test.c:142: note: skip.
test.c:142: note: ==> examining statement: D.7067_18 = D.7066_17 * 4;

test.c:142: note: skip.
test.c:142: note: ==> examining statement: D.7068_20 = image_19(D) + D.7067_18;

test.c:142: note: skip.
test.c:142: note: ==> examining statement: D.7069_21 = i_127 * j_132;

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 2 units of type int
test.c:142: note: vectype: vector(2) int
test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 2 units of type int
test.c:142: note: vectype: vector(2) int
test.c:142: note: vectype: vector(2) int
test.c:142: note: nunits = 2
test.c:142: note: ==> examining statement: D.7070_22 = D.7069_21 % 255;

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 2 units of type int
test.c:142: note: vectype: vector(2) int
test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 2 units of type int
test.c:142: note: vectype: vector(2) int
test.c:142: note: vectype: vector(2) int
test.c:142: note: nunits = 2
test.c:142: note: ==> examining statement: *D.7068_20 = D.7070_22;

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 2 units of type int
test.c:142: note: vectype: vector(2) int
test.c:142: note: vectype: vector(2) int
test.c:142: note: nunits = 2
test.c:142: note: ==> examining statement: j_23 = j_132 + 1;

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 2 units of type int
test.c:142: note: vectype: vector(2) int
test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 2 units of type int
test.c:142: note: vectype: vector(2) int
test.c:142: note: vectype: vector(2) int
test.c:142: note: nunits = 2
test.c:142: note: ==> examining statement: ivtmp.466_196 = ivtmp.466_197 - 1;

test.c:142: note: skip.
test.c:142: note: ==> examining statement: if (ivtmp.466_196 != 0)

test.c:142: note: skip.
test.c:142: note: ==> examining statement: i_24 = i_127 + 1;

test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 2 units of type int
test.c:142: note: vectype: vector(2) int
test.c:142: note: get vectype for scalar type:  int
test.c:142: note: get vectype with 2 units of type int
test.c:142: note: vectype: vector(2) int
test.c:142: note: vectype: vector(2) int
test.c:142: note: nunits = 2
test.c:142: note: ==> examining statement: ivtmp.465_198 = ivtmp.465_199 - 1;

test.c:142: note: skip.
test.c:142: note: ==> examining statement: if (ivtmp.465_198 != 0)

test.c:142: note: skip.
test.c:142: note: vectorization factor = 2
test.c:142: note: === vect_analyze_data_refs_alignment ===
test.c:142: note: vect_compute_data_ref_alignment:
test.c:142: note: inner step doesn't divide the vector-size.
test.c:142: note: Unknown alignment for access: *(image_19(D) + (unsigned int) ((unsigned int) i_127 * 16384))
test.c:142: note: === vect_analyze_data_ref_accesses ===
test.c:142: note: strided access in outer loop.
test.c:142: note: not vectorized: complicated access pattern.
test.c:142: note: bad data access.
test.c:143: note: ===== analyze_loop_nest =====
test.c:143: note: === vect_analyze_loop_form ===
test.c:143: note: === get_loop_niters ===
test.c:143: note: ==> get_loop_niters:4096
test.c:143: note: === vect_analyze_data_refs ===

test.c:143: note: get vectype with 4 units of type int
test.c:143: note: vectype: vector(4) int
test.c:143: note: === vect_analyze_scalar_cycles ===
test.c:143: note: Analyze phi: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: Access function of PHI: {0, +, 1}_3
test.c:143: note: step: 1,  init: 0
test.c:143: note: Detected induction.
test.c:143: note: Analyze phi: .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:143: note: Analyze phi: ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:143: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:143: note: step: 4294967295,  init: 4096
test.c:143: note: Detected induction.
test.c:143: note: === vect_pattern_recog ===
test.c:143: note: vect_is_simple_use: operand D.7066_17
test.c:143: note: def_stmt: D.7066_17 = (unsigned int) D.7065_16;

test.c:143: note: type of def: 3.
test.c:143: note: vect_is_simple_use: operand i_127
test.c:143: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:143: note: type of def: 2.
test.c:143: note: === vect_mark_stmts_to_be_vectorized ===
test.c:143: note: init: phi relevant? j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: init: phi relevant? .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:143: note: init: phi relevant? ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:143: note: init: stmt relevant? D.7065_16 = j_132 + pretmp.449_189;

test.c:143: note: init: stmt relevant? D.7066_17 = (unsigned int) D.7065_16;

test.c:143: note: init: stmt relevant? D.7067_18 = D.7066_17 * 4;

test.c:143: note: init: stmt relevant? D.7068_20 = image_19(D) + D.7067_18;

test.c:143: note: init: stmt relevant? D.7069_21 = i_127 * j_132;

test.c:143: note: init: stmt relevant? D.7070_22 = D.7069_21 % 255;

test.c:143: note: init: stmt relevant? *D.7068_20 = D.7070_22;

test.c:143: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:143: note: mark relevant 4, live 0.
test.c:143: note: init: stmt relevant? j_23 = j_132 + 1;

test.c:143: note: init: stmt relevant? ivtmp.466_196 = ivtmp.466_197 - 1;

test.c:143: note: init: stmt relevant? if (ivtmp.466_196 != 0)

test.c:143: note: worklist: examine stmt: *D.7068_20 = D.7070_22;

test.c:143: note: vect_is_simple_use: operand D.7070_22
test.c:143: note: def_stmt: D.7070_22 = D.7069_21 % 255;

test.c:143: note: type of def: 3.
test.c:143: note: mark relevant 4, live 0.
test.c:143: note: worklist: examine stmt: D.7070_22 = D.7069_21 % 255;

test.c:143: note: vect_is_simple_use: operand D.7069_21
test.c:143: note: def_stmt: D.7069_21 = i_127 * j_132;

test.c:143: note: type of def: 3.
test.c:143: note: mark relevant 4, live 0.
test.c:143: note: worklist: examine stmt: D.7069_21 = i_127 * j_132;

test.c:143: note: vect_is_simple_use: operand i_127
test.c:143: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:143: note: type of def: 2.
test.c:143: note: def_stmt is out of loop.
test.c:143: note: vect_is_simple_use: operand j_132
test.c:143: note: def_stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: type of def: 4.
test.c:143: note: mark relevant 4, live 0.
test.c:143: note: worklist: examine stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: vect_is_simple_use: operand j_23
test.c:143: note: def_stmt: j_23 = j_132 + 1;

test.c:143: note: type of def: 3.
test.c:143: note: mark relevant 4, live 0.
test.c:143: note: vect_is_simple_use: operand 0
test.c:143: note: worklist: examine stmt: j_23 = j_132 + 1;

test.c:143: note: vect_is_simple_use: operand j_132
test.c:143: note: def_stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: type of def: 4.
test.c:143: note: mark relevant 4, live 0.
test.c:143: note: already marked relevant/live.
test.c:143: note: === vect_analyze_dependences ===
test.c:143: note: === vect_determine_vectorization_factor ===
test.c:143: note: ==> examining phi: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 4 units of type int
test.c:143: note: vectype: vector(4) int
test.c:143: note: vectype: vector(4) int
test.c:143: note: nunits = 4
test.c:143: note: ==> examining phi: .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:143: note: ==> examining phi: ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:143: note: ==> examining statement: D.7065_16 = j_132 + pretmp.449_189;

test.c:143: note: skip.
test.c:143: note: ==> examining statement: D.7066_17 = (unsigned int) D.7065_16;

test.c:143: note: skip.
test.c:143: note: ==> examining statement: D.7067_18 = D.7066_17 * 4;

test.c:143: note: skip.
test.c:143: note: ==> examining statement: D.7068_20 = image_19(D) + D.7067_18;

test.c:143: note: skip.
test.c:143: note: ==> examining statement: D.7069_21 = i_127 * j_132;

test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 4 units of type int
test.c:143: note: vectype: vector(4) int
test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 4 units of type int
test.c:143: note: vectype: vector(4) int
test.c:143: note: vectype: vector(4) int
test.c:143: note: nunits = 4
test.c:143: note: ==> examining statement: D.7070_22 = D.7069_21 % 255;

test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 4 units of type int
test.c:143: note: vectype: vector(4) int
test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 4 units of type int
test.c:143: note: vectype: vector(4) int
test.c:143: note: vectype: vector(4) int
test.c:143: note: nunits = 4
test.c:143: note: ==> examining statement: *D.7068_20 = D.7070_22;

test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 4 units of type int
test.c:143: note: vectype: vector(4) int
test.c:143: note: vectype: vector(4) int
test.c:143: note: nunits = 4
test.c:143: note: ==> examining statement: j_23 = j_132 + 1;

test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 4 units of type int
test.c:143: note: vectype: vector(4) int
test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 4 units of type int
test.c:143: note: vectype: vector(4) int
test.c:143: note: vectype: vector(4) int
test.c:143: note: nunits = 4
test.c:143: note: ==> examining statement: ivtmp.466_196 = ivtmp.466_197 - 1;

test.c:143: note: skip.
test.c:143: note: ==> examining statement: if (ivtmp.466_196 != 0)

test.c:143: note: skip.
test.c:143: note: vectorization factor = 4
test.c:143: note: === vect_analyze_data_refs_alignment ===
test.c:143: note: vect_compute_data_ref_alignment:
test.c:143: note: can't force alignment of ref: *D.7068_20
test.c:143: note: === vect_analyze_data_ref_accesses ===
test.c:143: note: === vect_prune_runtime_alias_test_list ===
test.c:143: note: === vect_enhance_data_refs_alignment ===
test.c:143: note: Unknown misalignment, is_packed = 0
test.c:143: note: vect_can_advance_ivs_p:
test.c:143: note: Analyze phi: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: Access function of PHI: {0, +, 1}_3
test.c:143: note: Analyze phi: .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:143: note: virtual phi. skip.
test.c:143: note: Analyze phi: ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:143: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:143: note: Alignment of access forced using peeling.
test.c:143: note: Peeling for alignment will be applied.
test.c:143: note: === vect_analyze_slp ===
test.c:143: note: === vect_make_slp_decision ===
test.c:143: note: === vect_detect_hybrid_slp ===
test.c:143: note: === vect_analyze_loop_operations ===
test.c:143: note: examining phi: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: === vectorizable_induction ===
test.c:143: note: vect_model_induction_cost: inside_cost = 1, outside_cost = 2 .
test.c:143: note: examining phi: .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:143: note: examining phi: ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:143: note: ==> examining statement: D.7065_16 = j_132 + pretmp.449_189;

test.c:143: note: irrelevant.
test.c:143: note: ==> examining statement: D.7066_17 = (unsigned int) D.7065_16;

test.c:143: note: irrelevant.
test.c:143: note: ==> examining statement: D.7067_18 = D.7066_17 * 4;

test.c:143: note: irrelevant.
test.c:143: note: ==> examining statement: D.7068_20 = image_19(D) + D.7067_18;

test.c:143: note: irrelevant.
test.c:143: note: ==> examining statement: D.7069_21 = i_127 * j_132;

test.c:143: note: vect_is_simple_use: operand i_127
test.c:143: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:143: note: type of def: 2.
test.c:143: note: get vectype with 4 units of type int
test.c:143: note: vectype: vector(4) int
test.c:143: note: vect_is_simple_use: operand j_132
test.c:143: note: def_stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: type of def: 4.
test.c:143: note: === vectorizable_operation ===
test.c:143: note: vect_model_simple_cost: inside_cost = 1, outside_cost = 1 .
test.c:143: note: ==> examining statement: D.7070_22 = D.7069_21 % 255;

test.c:143: note: vect_is_simple_use: operand D.7069_21
test.c:143: note: def_stmt: D.7069_21 = i_127 * j_132;

test.c:143: note: type of def: 3.
test.c:143: note: vect_is_simple_use: operand 255
test.c:143: note: op not supported by target.
test.c:143: note: not vectorized: relevant stmt not supported: D.7070_22 = D.7069_21 % 255;

test.c:143: note: bad operation or unsupported loop bound.
test.c:143: note: ***** Re-trying analysis with vector size 8

test.c:143: note: === vect_analyze_loop_form ===
test.c:143: note: === get_loop_niters ===
test.c:143: note: ==> get_loop_niters:4096
test.c:143: note: === vect_analyze_data_refs ===

test.c:143: note: get vectype with 2 units of type int
test.c:143: note: vectype: vector(2) int
test.c:143: note: === vect_analyze_scalar_cycles ===
test.c:143: note: Analyze phi: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: Access function of PHI: {0, +, 1}_3
test.c:143: note: step: 1,  init: 0
test.c:143: note: Detected induction.
test.c:143: note: Analyze phi: .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:143: note: Analyze phi: ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:143: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:143: note: step: 4294967295,  init: 4096
test.c:143: note: Detected induction.
test.c:143: note: === vect_pattern_recog ===
test.c:143: note: vect_is_simple_use: operand D.7066_17
test.c:143: note: def_stmt: D.7066_17 = (unsigned int) D.7065_16;

test.c:143: note: type of def: 3.
test.c:143: note: vect_is_simple_use: operand i_127
test.c:143: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:143: note: type of def: 2.
test.c:143: note: === vect_mark_stmts_to_be_vectorized ===
test.c:143: note: init: phi relevant? j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: init: phi relevant? .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:143: note: init: phi relevant? ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:143: note: init: stmt relevant? D.7065_16 = j_132 + pretmp.449_189;

test.c:143: note: init: stmt relevant? D.7066_17 = (unsigned int) D.7065_16;

test.c:143: note: init: stmt relevant? D.7067_18 = D.7066_17 * 4;

test.c:143: note: init: stmt relevant? D.7068_20 = image_19(D) + D.7067_18;

test.c:143: note: init: stmt relevant? D.7069_21 = i_127 * j_132;

test.c:143: note: init: stmt relevant? D.7070_22 = D.7069_21 % 255;

test.c:143: note: init: stmt relevant? *D.7068_20 = D.7070_22;

test.c:143: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:143: note: mark relevant 4, live 0.
test.c:143: note: init: stmt relevant? j_23 = j_132 + 1;

test.c:143: note: init: stmt relevant? ivtmp.466_196 = ivtmp.466_197 - 1;

test.c:143: note: init: stmt relevant? if (ivtmp.466_196 != 0)

test.c:143: note: worklist: examine stmt: *D.7068_20 = D.7070_22;

test.c:143: note: vect_is_simple_use: operand D.7070_22
test.c:143: note: def_stmt: D.7070_22 = D.7069_21 % 255;

test.c:143: note: type of def: 3.
test.c:143: note: mark relevant 4, live 0.
test.c:143: note: worklist: examine stmt: D.7070_22 = D.7069_21 % 255;

test.c:143: note: vect_is_simple_use: operand D.7069_21
test.c:143: note: def_stmt: D.7069_21 = i_127 * j_132;

test.c:143: note: type of def: 3.
test.c:143: note: mark relevant 4, live 0.
test.c:143: note: worklist: examine stmt: D.7069_21 = i_127 * j_132;

test.c:143: note: vect_is_simple_use: operand i_127
test.c:143: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:143: note: type of def: 2.
test.c:143: note: def_stmt is out of loop.
test.c:143: note: vect_is_simple_use: operand j_132
test.c:143: note: def_stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: type of def: 4.
test.c:143: note: mark relevant 4, live 0.
test.c:143: note: worklist: examine stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: vect_is_simple_use: operand j_23
test.c:143: note: def_stmt: j_23 = j_132 + 1;

test.c:143: note: type of def: 3.
test.c:143: note: mark relevant 4, live 0.
test.c:143: note: vect_is_simple_use: operand 0
test.c:143: note: worklist: examine stmt: j_23 = j_132 + 1;

test.c:143: note: vect_is_simple_use: operand j_132
test.c:143: note: def_stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: type of def: 4.
test.c:143: note: mark relevant 4, live 0.
test.c:143: note: already marked relevant/live.
test.c:143: note: === vect_analyze_dependences ===
test.c:143: note: === vect_determine_vectorization_factor ===
test.c:143: note: ==> examining phi: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 2 units of type int
test.c:143: note: vectype: vector(2) int
test.c:143: note: vectype: vector(2) int
test.c:143: note: nunits = 2
test.c:143: note: ==> examining phi: .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:143: note: ==> examining phi: ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:143: note: ==> examining statement: D.7065_16 = j_132 + pretmp.449_189;

test.c:143: note: skip.
test.c:143: note: ==> examining statement: D.7066_17 = (unsigned int) D.7065_16;

test.c:143: note: skip.
test.c:143: note: ==> examining statement: D.7067_18 = D.7066_17 * 4;

test.c:143: note: skip.
test.c:143: note: ==> examining statement: D.7068_20 = image_19(D) + D.7067_18;

test.c:143: note: skip.
test.c:143: note: ==> examining statement: D.7069_21 = i_127 * j_132;

test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 2 units of type int
test.c:143: note: vectype: vector(2) int
test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 2 units of type int
test.c:143: note: vectype: vector(2) int
test.c:143: note: vectype: vector(2) int
test.c:143: note: nunits = 2
test.c:143: note: ==> examining statement: D.7070_22 = D.7069_21 % 255;

test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 2 units of type int
test.c:143: note: vectype: vector(2) int
test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 2 units of type int
test.c:143: note: vectype: vector(2) int
test.c:143: note: vectype: vector(2) int
test.c:143: note: nunits = 2
test.c:143: note: ==> examining statement: *D.7068_20 = D.7070_22;

test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 2 units of type int
test.c:143: note: vectype: vector(2) int
test.c:143: note: vectype: vector(2) int
test.c:143: note: nunits = 2
test.c:143: note: ==> examining statement: j_23 = j_132 + 1;

test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 2 units of type int
test.c:143: note: vectype: vector(2) int
test.c:143: note: get vectype for scalar type:  int
test.c:143: note: get vectype with 2 units of type int
test.c:143: note: vectype: vector(2) int
test.c:143: note: vectype: vector(2) int
test.c:143: note: nunits = 2
test.c:143: note: ==> examining statement: ivtmp.466_196 = ivtmp.466_197 - 1;

test.c:143: note: skip.
test.c:143: note: ==> examining statement: if (ivtmp.466_196 != 0)

test.c:143: note: skip.
test.c:143: note: vectorization factor = 2
test.c:143: note: === vect_analyze_data_refs_alignment ===
test.c:143: note: vect_compute_data_ref_alignment:
test.c:143: note: can't force alignment of ref: *D.7068_20
test.c:143: note: === vect_analyze_data_ref_accesses ===
test.c:143: note: === vect_prune_runtime_alias_test_list ===
test.c:143: note: === vect_enhance_data_refs_alignment ===
test.c:143: note: Unknown misalignment, is_packed = 0
test.c:143: note: vect_can_advance_ivs_p:
test.c:143: note: Analyze phi: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: Access function of PHI: {0, +, 1}_3
test.c:143: note: Analyze phi: .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:143: note: virtual phi. skip.
test.c:143: note: Analyze phi: ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:143: note: Access function of PHI: {4096, +, 4294967295}_3
test.c:143: note: Alignment of access forced using peeling.
test.c:143: note: Peeling for alignment will be applied.
test.c:143: note: === vect_analyze_slp ===
test.c:143: note: === vect_make_slp_decision ===
test.c:143: note: === vect_detect_hybrid_slp ===
test.c:143: note: === vect_analyze_loop_operations ===
test.c:143: note: examining phi: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: === vectorizable_induction ===
test.c:143: note: vect_model_induction_cost: inside_cost = 1, outside_cost = 2 .
test.c:143: note: examining phi: .MEM_137 = PHI <.MEM_97(3), .MEM_107(7)>

test.c:143: note: examining phi: ivtmp.466_197 = PHI <ivtmp.466_196(3), 4096(7)>

test.c:143: note: ==> examining statement: D.7065_16 = j_132 + pretmp.449_189;

test.c:143: note: irrelevant.
test.c:143: note: ==> examining statement: D.7066_17 = (unsigned int) D.7065_16;

test.c:143: note: irrelevant.
test.c:143: note: ==> examining statement: D.7067_18 = D.7066_17 * 4;

test.c:143: note: irrelevant.
test.c:143: note: ==> examining statement: D.7068_20 = image_19(D) + D.7067_18;

test.c:143: note: irrelevant.
test.c:143: note: ==> examining statement: D.7069_21 = i_127 * j_132;

test.c:143: note: vect_is_simple_use: operand i_127
test.c:143: note: def_stmt: i_127 = PHI <0(28), i_24(6)>

test.c:143: note: type of def: 2.
test.c:143: note: get vectype with 2 units of type int
test.c:143: note: vectype: vector(2) int
test.c:143: note: vect_is_simple_use: operand j_132
test.c:143: note: def_stmt: j_132 = PHI <j_23(3), 0(7)>

test.c:143: note: type of def: 4.
test.c:143: note: === vectorizable_operation ===
test.c:143: note: vect_model_simple_cost: inside_cost = 1, outside_cost = 1 .
test.c:143: note: ==> examining statement: D.7070_22 = D.7069_21 % 255;

test.c:143: note: vect_is_simple_use: operand D.7069_21
test.c:143: note: def_stmt: D.7069_21 = i_127 * j_132;

test.c:143: note: type of def: 3.
test.c:143: note: vect_is_simple_use: operand 255
test.c:143: note: op not supported by target.
test.c:143: note: not vectorized: relevant stmt not supported: D.7070_22 = D.7069_21 % 255;

test.c:143: note: bad operation or unsupported loop bound.
test.c:133: note: vectorized 1 loops in function.

test.c:186: note: ===== analyze_loop_nest =====
test.c:186: note: === vect_analyze_loop_form ===
test.c:186: note: not vectorized: multiple nested loops.
test.c:186: note: bad loop form.
test.c:84: note: ===== analyze_loop_nest =====
test.c:84: note: === vect_analyze_loop_form ===
test.c:84: note: ===== analyze_loop_nest_1 =====
test.c:84: note: === vect_analyze_loop_form ===
test.c:84: note: === get_loop_niters ===
test.c:84: note: ==> get_loop_niters:4096
test.c:84: note: Considering outer-loop vectorization.
test.c:84: note: === get_loop_niters ===
test.c:84: note: ==> get_loop_niters:((unsigned int) ~start_indx_20(D) + (unsigned int) end_indx_21(D)) + 1
test.c:84: note: Symbolic number of iterations is ((unsigned int) ~start_indx_20(D) + (unsigned int) end_indx_21(D)) + 1
test.c:84: note: === vect_analyze_data_refs ===

test.c:84: note: analyze in outer-loop: *((int * restrict) D.7194_75 + (unsigned int) ((unsigned int) start_indx_79 * 16384))
test.c:84: note: 	outer base_address: (int *) D.7194_75 + (unsigned int) ((unsigned int) start_indx_20(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:84: note: get vectype with 4 units of type int
test.c:84: note: vectype: vector(4) int
test.c:84: note: not vectorized: data ref analysis failed D.7187_85 = a9_gray_level_mapping[D.7188_84];

test.c:84: note: bad data references.
test.c:84: note: ***** Re-trying analysis with vector size 8

test.c:84: note: === vect_analyze_loop_form ===
test.c:84: note: ===== analyze_loop_nest_1 =====
test.c:84: note: === vect_analyze_loop_form ===
test.c:84: note: === get_loop_niters ===
test.c:84: note: ==> get_loop_niters:4096
test.c:84: note: Considering outer-loop vectorization.
test.c:84: note: === get_loop_niters ===
test.c:84: note: ==> get_loop_niters:((unsigned int) ~start_indx_20(D) + (unsigned int) end_indx_21(D)) + 1
test.c:84: note: Symbolic number of iterations is ((unsigned int) ~start_indx_20(D) + (unsigned int) end_indx_21(D)) + 1
test.c:84: note: === vect_analyze_data_refs ===

test.c:84: note: analyze in outer-loop: *((int * restrict) D.7194_75 + (unsigned int) ((unsigned int) start_indx_79 * 16384))
test.c:84: note: 	outer base_address: (int *) D.7194_75 + (unsigned int) ((unsigned int) start_indx_20(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:84: note: get vectype with 2 units of type int
test.c:84: note: vectype: vector(2) int
test.c:84: note: not vectorized: data ref analysis failed D.7187_85 = a9_gray_level_mapping[D.7188_84];

test.c:84: note: bad data references.
test.c:85: note: ===== analyze_loop_nest =====
test.c:85: note: === vect_analyze_loop_form ===
test.c:85: note: === get_loop_niters ===
test.c:85: note: ==> get_loop_niters:4096
test.c:85: note: === vect_analyze_data_refs ===

test.c:85: note: get vectype with 4 units of type int
test.c:85: note: vectype: vector(4) int
test.c:85: note: not vectorized: data ref analysis failed D.7187_85 = a9_gray_level_mapping[D.7188_84];

test.c:85: note: bad data references.
test.c:85: note: ***** Re-trying analysis with vector size 8

test.c:85: note: === vect_analyze_loop_form ===
test.c:85: note: === get_loop_niters ===
test.c:85: note: ==> get_loop_niters:4096
test.c:85: note: === vect_analyze_data_refs ===

test.c:85: note: get vectype with 2 units of type int
test.c:85: note: vectype: vector(2) int
test.c:85: note: not vectorized: data ref analysis failed D.7187_85 = a9_gray_level_mapping[D.7188_84];

test.c:85: note: bad data references.
test.c:100: note: ===== analyze_loop_nest =====
test.c:100: note: === vect_analyze_loop_form ===
test.c:100: note: ===== analyze_loop_nest_1 =====
test.c:100: note: === vect_analyze_loop_form ===
test.c:100: note: === get_loop_niters ===
test.c:100: note: ==> get_loop_niters:4096
test.c:100: note: Considering outer-loop vectorization.
test.c:100: note: === get_loop_niters ===
test.c:100: note: ==> get_loop_niters:((unsigned int) ~start_indx_20(D) + (unsigned int) end_indx_21(D)) + 1
test.c:100: note: Symbolic number of iterations is ((unsigned int) ~start_indx_20(D) + (unsigned int) end_indx_21(D)) + 1
test.c:100: note: === vect_analyze_data_refs ===

test.c:100: note: analyze in outer-loop: *((int * restrict) D.7210_90 + (unsigned int) ((unsigned int) start_indx_122 * 16384))
test.c:100: note: 	outer base_address: (int *) D.7210_90 + (unsigned int) ((unsigned int) start_indx_20(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:100: note: get vectype with 4 units of type int
test.c:100: note: vectype: vector(4) int
test.c:100: note: not vectorized: data ref analysis failed D.7203_100 = a9_gray_level_mapping[D.7204_99];

test.c:100: note: bad data references.
test.c:100: note: ***** Re-trying analysis with vector size 8

test.c:100: note: === vect_analyze_loop_form ===
test.c:100: note: ===== analyze_loop_nest_1 =====
test.c:100: note: === vect_analyze_loop_form ===
test.c:100: note: === get_loop_niters ===
test.c:100: note: ==> get_loop_niters:4096
test.c:100: note: Considering outer-loop vectorization.
test.c:100: note: === get_loop_niters ===
test.c:100: note: ==> get_loop_niters:((unsigned int) ~start_indx_20(D) + (unsigned int) end_indx_21(D)) + 1
test.c:100: note: Symbolic number of iterations is ((unsigned int) ~start_indx_20(D) + (unsigned int) end_indx_21(D)) + 1
test.c:100: note: === vect_analyze_data_refs ===

test.c:100: note: analyze in outer-loop: *((int * restrict) D.7210_90 + (unsigned int) ((unsigned int) start_indx_122 * 16384))
test.c:100: note: 	outer base_address: (int *) D.7210_90 + (unsigned int) ((unsigned int) start_indx_20(D) * 16384)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:100: note: get vectype with 2 units of type int
test.c:100: note: vectype: vector(2) int
test.c:100: note: not vectorized: data ref analysis failed D.7203_100 = a9_gray_level_mapping[D.7204_99];

test.c:100: note: bad data references.
test.c:101: note: ===== analyze_loop_nest =====
test.c:101: note: === vect_analyze_loop_form ===
test.c:101: note: === get_loop_niters ===
test.c:101: note: ==> get_loop_niters:4096
test.c:101: note: === vect_analyze_data_refs ===

test.c:101: note: get vectype with 4 units of type int
test.c:101: note: vectype: vector(4) int
test.c:101: note: not vectorized: data ref analysis failed D.7203_100 = a9_gray_level_mapping[D.7204_99];

test.c:101: note: bad data references.
test.c:101: note: ***** Re-trying analysis with vector size 8

test.c:101: note: === vect_analyze_loop_form ===
test.c:101: note: === get_loop_niters ===
test.c:101: note: ==> get_loop_niters:4096
test.c:101: note: === vect_analyze_data_refs ===

test.c:101: note: get vectype with 2 units of type int
test.c:101: note: vectype: vector(2) int
test.c:101: note: not vectorized: data ref analysis failed D.7203_100 = a9_gray_level_mapping[D.7204_99];

test.c:101: note: bad data references.
test.c:178: note: vectorized 0 loops in function.

test.c:224: note: ===== analyze_loop_nest =====
test.c:224: note: === vect_analyze_loop_form ===
test.c:224: note: not vectorized: control flow in loop.
test.c:224: note: bad loop form.
test.c:221: note: vectorized 0 loops in function.

test.c:252: note: ===== analyze_loop_nest =====
test.c:252: note: === vect_analyze_loop_form ===
test.c:252: note: not vectorized: multiple nested loops.
test.c:252: note: bad loop form.
test.c:254: note: ===== analyze_loop_nest =====
test.c:254: note: === vect_analyze_loop_form ===
test.c:254: note: ===== analyze_loop_nest_1 =====
test.c:254: note: === vect_analyze_loop_form ===
test.c:254: note: === get_loop_niters ===
test.c:254: note: ==> get_loop_niters:4096
test.c:254: note: Considering outer-loop vectorization.
test.c:254: note: === get_loop_niters ===
test.c:254: note: ==> get_loop_niters:4096
test.c:254: note: === vect_analyze_data_refs ===

test.c:254: note: analyze in outer-loop: *((int *) pretmp.699_10 + (unsigned int) ((unsigned int) j_54 * 16384))
test.c:254: note: 	outer base_address: (int *) pretmp.699_10
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:254: note: get vectype with 4 units of type int
test.c:254: note: vectype: vector(4) int
test.c:254: note: === vect_analyze_scalar_cycles ===
test.c:254: note: Analyze phi: .MEM_24 = PHI <.MEM_4(6), .MEM_47(10)>

test.c:254: note: Analyze phi: j_54 = PHI <0(6), j_22(10)>

test.c:254: note: Access function of PHI: {0, +, 1}_4
test.c:254: note: step: 1,  init: 0
test.c:254: note: Detected induction.
test.c:254: note: Analyze phi: ivtmp.708_41 = PHI <4096(6), ivtmp.708_14(10)>

test.c:254: note: Access function of PHI: {4096, +, 4294967295}_4
test.c:254: note: step: 4294967295,  init: 4096
test.c:254: note: Detected induction.
test.c:254: note: === vect_analyze_scalar_cycles ===
test.c:254: note: Analyze phi: k_61 = PHI <k_21(7), 0(11)>

test.c:254: note: Access function of PHI: {0, +, 1}_5
test.c:254: note: step: 1,  init: 0
test.c:254: note: Detected induction.
test.c:254: note: Analyze phi: .MEM_62 = PHI <.MEM_47(7), .MEM_24(11)>

test.c:254: note: Analyze phi: ivtmp.709_15 = PHI <ivtmp.709_16(7), 4096(11)>

test.c:254: note: Access function of PHI: {4096, +, 4294967295}_5
test.c:254: note: step: 4294967295,  init: 4096
test.c:254: note: Detected induction.
test.c:254: note: === vect_pattern_recog ===
test.c:254: note: vect_is_simple_use: operand j_54
test.c:254: note: def_stmt: j_54 = PHI <0(6), j_22(10)>

test.c:254: note: type of def: 4.
test.c:254: note: vect_is_simple_use: operand D.7022_18
test.c:254: note: def_stmt: D.7022_18 = (unsigned int) D.7021_17;

test.c:254: note: type of def: 3.
test.c:254: note: === vect_mark_stmts_to_be_vectorized ===
test.c:254: note: init: phi relevant? .MEM_24 = PHI <.MEM_4(6), .MEM_47(10)>

test.c:254: note: init: phi relevant? j_54 = PHI <0(6), j_22(10)>

test.c:254: note: init: phi relevant? ivtmp.708_41 = PHI <4096(6), ivtmp.708_14(10)>

test.c:254: note: init: stmt relevant? pretmp.703_68 = j_54 * 4096;

test.c:254: note: init: phi relevant? k_61 = PHI <k_21(7), 0(11)>

test.c:254: note: init: phi relevant? .MEM_62 = PHI <.MEM_47(7), .MEM_24(11)>

test.c:254: note: init: phi relevant? ivtmp.709_15 = PHI <ivtmp.709_16(7), 4096(11)>

test.c:254: note: init: stmt relevant? D.7021_17 = k_61 + pretmp.703_68;

test.c:254: note: init: stmt relevant? D.7022_18 = (unsigned int) D.7021_17;

test.c:254: note: init: stmt relevant? D.7023_19 = D.7022_18 * 4;

test.c:254: note: init: stmt relevant? D.7024_20 = pretmp.699_10 + D.7023_19;

test.c:254: note: init: stmt relevant? *D.7024_20 = 0;

test.c:254: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:254: note: mark relevant 4, live 0.
test.c:254: note: init: stmt relevant? k_21 = k_61 + 1;

test.c:254: note: init: stmt relevant? ivtmp.709_16 = ivtmp.709_15 - 1;

test.c:254: note: init: stmt relevant? if (ivtmp.709_16 != 0)

test.c:254: note: init: stmt relevant? j_22 = j_54 + 1;

test.c:254: note: init: stmt relevant? ivtmp.708_14 = ivtmp.708_41 - 1;

test.c:254: note: init: stmt relevant? if (ivtmp.708_14 != 0)

test.c:254: note: worklist: examine stmt: *D.7024_20 = 0;

test.c:254: note: === vect_analyze_dependences ===
test.c:254: note: === vect_determine_vectorization_factor ===
test.c:254: note: ==> examining phi: .MEM_24 = PHI <.MEM_4(6), .MEM_47(10)>

test.c:254: note: ==> examining phi: j_54 = PHI <0(6), j_22(10)>

test.c:254: note: ==> examining phi: ivtmp.708_41 = PHI <4096(6), ivtmp.708_14(10)>

test.c:254: note: ==> examining statement: pretmp.703_68 = j_54 * 4096;

test.c:254: note: skip.
test.c:254: note: ==> examining phi: k_61 = PHI <k_21(7), 0(11)>

test.c:254: note: ==> examining phi: .MEM_62 = PHI <.MEM_47(7), .MEM_24(11)>

test.c:254: note: ==> examining phi: ivtmp.709_15 = PHI <ivtmp.709_16(7), 4096(11)>

test.c:254: note: ==> examining statement: D.7021_17 = k_61 + pretmp.703_68;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: D.7022_18 = (unsigned int) D.7021_17;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: D.7023_19 = D.7022_18 * 4;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: D.7024_20 = pretmp.699_10 + D.7023_19;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: *D.7024_20 = 0;

test.c:254: note: get vectype for scalar type:  int
test.c:254: note: get vectype with 4 units of type int
test.c:254: note: vectype: vector(4) int
test.c:254: note: vectype: vector(4) int
test.c:254: note: nunits = 4
test.c:254: note: ==> examining statement: k_21 = k_61 + 1;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: ivtmp.709_16 = ivtmp.709_15 - 1;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: if (ivtmp.709_16 != 0)

test.c:254: note: skip.
test.c:254: note: ==> examining statement: j_22 = j_54 + 1;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: ivtmp.708_14 = ivtmp.708_41 - 1;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: if (ivtmp.708_14 != 0)

test.c:254: note: skip.
test.c:254: note: vectorization factor = 4
test.c:254: note: === vect_analyze_data_refs_alignment ===
test.c:254: note: vect_compute_data_ref_alignment:
test.c:254: note: inner step doesn't divide the vector-size.
test.c:254: note: Unknown alignment for access: *((int *) pretmp.699_10 + (unsigned int) ((unsigned int) j_54 * 16384))
test.c:254: note: === vect_analyze_data_ref_accesses ===
test.c:254: note: strided access in outer loop.
test.c:254: note: not vectorized: complicated access pattern.
test.c:254: note: bad data access.
test.c:254: note: ***** Re-trying analysis with vector size 8

test.c:254: note: === vect_analyze_loop_form ===
test.c:254: note: ===== analyze_loop_nest_1 =====
test.c:254: note: === vect_analyze_loop_form ===
test.c:254: note: === get_loop_niters ===
test.c:254: note: ==> get_loop_niters:4096
test.c:254: note: Considering outer-loop vectorization.
test.c:254: note: === get_loop_niters ===
test.c:254: note: ==> get_loop_niters:4096
test.c:254: note: === vect_analyze_data_refs ===

test.c:254: note: analyze in outer-loop: *((int *) pretmp.699_10 + (unsigned int) ((unsigned int) j_54 * 16384))
test.c:254: note: 	outer base_address: (int *) pretmp.699_10
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 16384
	outer aligned to: 64
test.c:254: note: get vectype with 2 units of type int
test.c:254: note: vectype: vector(2) int
test.c:254: note: === vect_analyze_scalar_cycles ===
test.c:254: note: Analyze phi: .MEM_24 = PHI <.MEM_4(6), .MEM_47(10)>

test.c:254: note: Analyze phi: j_54 = PHI <0(6), j_22(10)>

test.c:254: note: Access function of PHI: {0, +, 1}_4
test.c:254: note: step: 1,  init: 0
test.c:254: note: Detected induction.
test.c:254: note: Analyze phi: ivtmp.708_41 = PHI <4096(6), ivtmp.708_14(10)>

test.c:254: note: Access function of PHI: {4096, +, 4294967295}_4
test.c:254: note: step: 4294967295,  init: 4096
test.c:254: note: Detected induction.
test.c:254: note: === vect_analyze_scalar_cycles ===
test.c:254: note: Analyze phi: k_61 = PHI <k_21(7), 0(11)>

test.c:254: note: Access function of PHI: {0, +, 1}_5
test.c:254: note: step: 1,  init: 0
test.c:254: note: Detected induction.
test.c:254: note: Analyze phi: .MEM_62 = PHI <.MEM_47(7), .MEM_24(11)>

test.c:254: note: Analyze phi: ivtmp.709_15 = PHI <ivtmp.709_16(7), 4096(11)>

test.c:254: note: Access function of PHI: {4096, +, 4294967295}_5
test.c:254: note: step: 4294967295,  init: 4096
test.c:254: note: Detected induction.
test.c:254: note: === vect_pattern_recog ===
test.c:254: note: vect_is_simple_use: operand j_54
test.c:254: note: def_stmt: j_54 = PHI <0(6), j_22(10)>

test.c:254: note: type of def: 4.
test.c:254: note: vect_is_simple_use: operand D.7022_18
test.c:254: note: def_stmt: D.7022_18 = (unsigned int) D.7021_17;

test.c:254: note: type of def: 3.
test.c:254: note: === vect_mark_stmts_to_be_vectorized ===
test.c:254: note: init: phi relevant? .MEM_24 = PHI <.MEM_4(6), .MEM_47(10)>

test.c:254: note: init: phi relevant? j_54 = PHI <0(6), j_22(10)>

test.c:254: note: init: phi relevant? ivtmp.708_41 = PHI <4096(6), ivtmp.708_14(10)>

test.c:254: note: init: stmt relevant? pretmp.703_68 = j_54 * 4096;

test.c:254: note: init: phi relevant? k_61 = PHI <k_21(7), 0(11)>

test.c:254: note: init: phi relevant? .MEM_62 = PHI <.MEM_47(7), .MEM_24(11)>

test.c:254: note: init: phi relevant? ivtmp.709_15 = PHI <ivtmp.709_16(7), 4096(11)>

test.c:254: note: init: stmt relevant? D.7021_17 = k_61 + pretmp.703_68;

test.c:254: note: init: stmt relevant? D.7022_18 = (unsigned int) D.7021_17;

test.c:254: note: init: stmt relevant? D.7023_19 = D.7022_18 * 4;

test.c:254: note: init: stmt relevant? D.7024_20 = pretmp.699_10 + D.7023_19;

test.c:254: note: init: stmt relevant? *D.7024_20 = 0;

test.c:254: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:254: note: mark relevant 4, live 0.
test.c:254: note: init: stmt relevant? k_21 = k_61 + 1;

test.c:254: note: init: stmt relevant? ivtmp.709_16 = ivtmp.709_15 - 1;

test.c:254: note: init: stmt relevant? if (ivtmp.709_16 != 0)

test.c:254: note: init: stmt relevant? j_22 = j_54 + 1;

test.c:254: note: init: stmt relevant? ivtmp.708_14 = ivtmp.708_41 - 1;

test.c:254: note: init: stmt relevant? if (ivtmp.708_14 != 0)

test.c:254: note: worklist: examine stmt: *D.7024_20 = 0;

test.c:254: note: === vect_analyze_dependences ===
test.c:254: note: === vect_determine_vectorization_factor ===
test.c:254: note: ==> examining phi: .MEM_24 = PHI <.MEM_4(6), .MEM_47(10)>

test.c:254: note: ==> examining phi: j_54 = PHI <0(6), j_22(10)>

test.c:254: note: ==> examining phi: ivtmp.708_41 = PHI <4096(6), ivtmp.708_14(10)>

test.c:254: note: ==> examining statement: pretmp.703_68 = j_54 * 4096;

test.c:254: note: skip.
test.c:254: note: ==> examining phi: k_61 = PHI <k_21(7), 0(11)>

test.c:254: note: ==> examining phi: .MEM_62 = PHI <.MEM_47(7), .MEM_24(11)>

test.c:254: note: ==> examining phi: ivtmp.709_15 = PHI <ivtmp.709_16(7), 4096(11)>

test.c:254: note: ==> examining statement: D.7021_17 = k_61 + pretmp.703_68;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: D.7022_18 = (unsigned int) D.7021_17;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: D.7023_19 = D.7022_18 * 4;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: D.7024_20 = pretmp.699_10 + D.7023_19;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: *D.7024_20 = 0;

test.c:254: note: get vectype for scalar type:  int
test.c:254: note: get vectype with 2 units of type int
test.c:254: note: vectype: vector(2) int
test.c:254: note: vectype: vector(2) int
test.c:254: note: nunits = 2
test.c:254: note: ==> examining statement: k_21 = k_61 + 1;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: ivtmp.709_16 = ivtmp.709_15 - 1;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: if (ivtmp.709_16 != 0)

test.c:254: note: skip.
test.c:254: note: ==> examining statement: j_22 = j_54 + 1;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: ivtmp.708_14 = ivtmp.708_41 - 1;

test.c:254: note: skip.
test.c:254: note: ==> examining statement: if (ivtmp.708_14 != 0)

test.c:254: note: skip.
test.c:254: note: vectorization factor = 2
test.c:254: note: === vect_analyze_data_refs_alignment ===
test.c:254: note: vect_compute_data_ref_alignment:
test.c:254: note: inner step doesn't divide the vector-size.
test.c:254: note: Unknown alignment for access: *((int *) pretmp.699_10 + (unsigned int) ((unsigned int) j_54 * 16384))
test.c:254: note: === vect_analyze_data_ref_accesses ===
test.c:254: note: strided access in outer loop.
test.c:254: note: not vectorized: complicated access pattern.
test.c:254: note: bad data access.
test.c:255: note: ===== analyze_loop_nest =====
test.c:255: note: === vect_analyze_loop_form ===
test.c:255: note: === get_loop_niters ===
test.c:255: note: ==> get_loop_niters:4096
test.c:255: note: === vect_analyze_data_refs ===

test.c:255: note: get vectype with 4 units of type int
test.c:255: note: vectype: vector(4) int
test.c:255: note: === vect_analyze_scalar_cycles ===
test.c:255: note: Analyze phi: k_61 = PHI <k_21(7), 0(11)>

test.c:255: note: Access function of PHI: {0, +, 1}_5
test.c:255: note: step: 1,  init: 0
test.c:255: note: Detected induction.
test.c:255: note: Analyze phi: .MEM_62 = PHI <.MEM_47(7), .MEM_24(11)>

test.c:255: note: Analyze phi: ivtmp.709_15 = PHI <ivtmp.709_16(7), 4096(11)>

test.c:255: note: Access function of PHI: {4096, +, 4294967295}_5
test.c:255: note: step: 4294967295,  init: 4096
test.c:255: note: Detected induction.
test.c:255: note: === vect_pattern_recog ===
test.c:255: note: vect_is_simple_use: operand D.7022_18
test.c:255: note: def_stmt: D.7022_18 = (unsigned int) D.7021_17;

test.c:255: note: type of def: 3.
test.c:255: note: === vect_mark_stmts_to_be_vectorized ===
test.c:255: note: init: phi relevant? k_61 = PHI <k_21(7), 0(11)>

test.c:255: note: init: phi relevant? .MEM_62 = PHI <.MEM_47(7), .MEM_24(11)>

test.c:255: note: init: phi relevant? ivtmp.709_15 = PHI <ivtmp.709_16(7), 4096(11)>

test.c:255: note: init: stmt relevant? D.7021_17 = k_61 + pretmp.703_68;

test.c:255: note: init: stmt relevant? D.7022_18 = (unsigned int) D.7021_17;

test.c:255: note: init: stmt relevant? D.7023_19 = D.7022_18 * 4;

test.c:255: note: init: stmt relevant? D.7024_20 = pretmp.699_10 + D.7023_19;

test.c:255: note: init: stmt relevant? *D.7024_20 = 0;

test.c:255: note: vec_stmt_relevant_p: stmt has vdefs.
test.c:255: note: mark relevant 4, live 0.
test.c:255: note: init: stmt relevant? k_21 = k_61 + 1;

test.c:255: note: init: stmt relevant? ivtmp.709_16 = ivtmp.709_15 - 1;

test.c:255: note: init: stmt relevant? if (ivtmp.709_16 != 0)

test.c:255: note: worklist: examine stmt: *D.7024_20 = 0;

test.c:255: note: === vect_analyze_dependences ===
test.c:255: note: === vect_determine_vectorization_factor ===
test.c:255: note: ==> examining phi: k_61 = PHI <k_21(7), 0(11)>

test.c:255: note: ==> examining phi: .MEM_62 = PHI <.MEM_47(7), .MEM_24(11)>

test.c:255: note: ==> examining phi: ivtmp.709_15 = PHI <ivtmp.709_16(7), 4096(11)>

test.c:255: note: ==> examining statement: D.7021_17 = k_61 + pretmp.703_68;

test.c:255: note: skip.
test.c:255: note: ==> examining statement: D.7022_18 = (unsigned int) D.7021_17;

test.c:255: note: skip.
test.c:255: note: ==> examining statement: D.7023_19 = D.7022_18 * 4;

test.c:255: note: skip.
test.c:255: note: ==> examining statement: D.7024_20 = pretmp.699_10 + D.7023_19;

test.c:255: note: skip.
test.c:255: note: ==> examining statement: *D.7024_20 = 0;

test.c:255: note: get vectype for scalar type:  int
test.c:255: note: get vectype with 4 units of type int
test.c:255: note: vectype: vector(4) int
test.c:255: note: vectype: vector(4) int
test.c:255: note: nunits = 4
test.c:255: note: ==> examining statement: k_21 = k_61 + 1;

test.c:255: note: skip.
test.c:255: note: ==> examining statement: ivtmp.709_16 = ivtmp.709_15 - 1;

test.c:255: note: skip.
test.c:255: note: ==> examining statement: if (ivtmp.709_16 != 0)

test.c:255: note: skip.
test.c:255: note: vectorization factor = 4
test.c:255: note: === vect_analyze_data_refs_alignment ===
test.c:255: note: vect_compute_data_ref_alignment:
test.c:255: note: can't force alignment of ref: *D.7024_20
test.c:255: note: === vect_analyze_data_ref_accesses ===
test.c:255: note: === vect_prune_runtime_alias_test_list ===
test.c:255: note: === vect_enhance_data_refs_alignment ===
test.c:255: note: Unknown misalignment, is_packed = 0
test.c:255: note: vect_can_advance_ivs_p:
test.c:255: note: Analyze phi: k_61 = PHI <k_21(7), 0(11)>

test.c:255: note: Access function of PHI: {0, +, 1}_5
test.c:255: note: Analyze phi: .MEM_62 = PHI <.MEM_47(7), .MEM_24(11)>

test.c:255: note: virtual phi. skip.
test.c:255: note: Analyze phi: ivtmp.709_15 = PHI <ivtmp.709_16(7), 4096(11)>

test.c:255: note: Access function of PHI: {4096, +, 4294967295}_5
test.c:255: note: Alignment of access forced using peeling.
test.c:255: note: Peeling for alignment will be applied.
test.c:255: note: === vect_analyze_slp ===
test.c:255: note: === vect_make_slp_decision ===
test.c:255: note: === vect_detect_hybrid_slp ===
test.c:255: note: === vect_analyze_loop_operations ===
test.c:255: note: examining phi: k_61 = PHI <k_21(7), 0(11)>

test.c:255: note: examining phi: .MEM_62 = PHI <.MEM_47(7), .MEM_24(11)>

test.c:255: note: examining phi: ivtmp.709_15 = PHI <ivtmp.709_16(7), 4096(11)>

test.c:255: note: ==> examining statement: D.7021_17 = k_61 + pretmp.703_68;

test.c:255: note: irrelevant.
test.c:255: note: ==> examining statement: D.7022_18 = (unsigned int) D.7021_17;

test.c:255: note: irrelevant.
test.c:255: note: ==> examining statement: D.7023_19 = D.7022_18 * 4;

test.c:255: note: irrelevant.
test.c:255: note: ==> examining statement: D.7024_20 = pretmp.699_10 + D.7023_19;

test.c:255: note: irrelevant.
test.c:255: note: ==> examining statement: *D.7024_20 = 0;

test.c:255: note: vect_is_simple_use: operand 0
test.c:255: note: vect_model_store_cost: aligned.
test.c:255: note: vect_model_store_cost: inside_cost = 1, outside_cost = 1 .
test.c:255: note: ==> examining statement: k_21 = k_61 + 1;

test.c:255: note: irrelevant.
test.c:255: note: ==> examining statement: ivtmp.709_16 = ivtmp.709_15 - 1;

test.c:255: note: irrelevant.
test.c:255: note: ==> examining statement: if (ivtmp.709_16 != 0)

test.c:255: note: irrelevant.
test.c:255: note: vectorization_factor = 4, niters = 4096
test.c:255: note: === vect_update_slp_costs_according_to_vf ===
test.c:255: note: cost model disabled.
test.c:255: note: epilog loop required.
test.c:255: note: vect_can_advance_ivs_p:
test.c:255: note: Analyze phi: k_61 = PHI <k_21(7), 0(11)>

test.c:255: note: Access function of PHI: {0, +, 1}_5
test.c:255: note: Analyze phi: .MEM_62 = PHI <.MEM_47(7), .MEM_24(11)>

test.c:255: note: virtual phi. skip.
test.c:255: note: Analyze phi: ivtmp.709_15 = PHI <ivtmp.709_16(7), 4096(11)>

test.c:255: note: Access function of PHI: {4096, +, 4294967295}_5
test.c:255: note: === vec_transform_loop ===
test.c:255: note: === vect_do_peeling_for_alignment ===
test.c:255: note: created vect_p.714_67
test.c:255: note: niters for prolog loop: -(((unsigned int) vect_p.714_67 & 15) >> 2) & 3
test.c:255: note: Profitability threshold is 3 loop iterations.
test.c:255: note: === vect_update_inits_of_dr ===
test.c:255: note: === vect_do_peeling_for_loop_bound ===
test.c:255: note: vect_update_ivs_after_vectorizer: phi: k_61 = PHI <k_21(7), k_87(34)>

test.c:255: note: vect_update_ivs_after_vectorizer: phi: .MEM_62 = PHI <.MEM_47(7), .MEM_89(34)>

test.c:255: note: virtual phi. skip.
test.c:255: note: vect_update_ivs_after_vectorizer: phi: ivtmp.709_15 = PHI <ivtmp.709_16(7), ivtmp.709_90(34)>

test.c:255: note: ------>vectorizing phi: k_61 = PHI <k_21(7), k_87(39)>

test.c:255: note: ------>vectorizing phi: .MEM_62 = PHI <.MEM_47(7), .MEM_89(39)>

test.c:255: note: ------>vectorizing phi: ivtmp.709_15 = PHI <ivtmp.709_16(7), ivtmp.709_90(39)>

test.c:255: note: ------>vectorizing statement: D.7021_17 = k_61 + pretmp.703_68;

test.c:255: note: ------>vectorizing statement: D.7022_18 = (unsigned int) D.7021_17;

test.c:255: note: ------>vectorizing statement: D.7023_19 = D.7022_18 * 4;

test.c:255: note: ------>vectorizing statement: D.7024_20 = pretmp.699_10 + D.7023_19;

test.c:255: note: ------>vectorizing statement: *D.7024_20 = 0;

test.c:255: note: transform statement.
test.c:255: note: vect_is_simple_use: operand 0
test.c:255: note: transform store. ncopies = 1
test.c:255: note: vect_get_vec_def_for_operand: 0
test.c:255: note: vect_is_simple_use: operand 0
test.c:255: note: 
test.c:255: note: get vectype with 4 units of type int
test.c:255: note: vectype: vector(4) int
test.c:255: note: Create vector_cst. nunits = 4
test.c:255: note: created new init_stmt: vect_cst_.723_118 = { 0, 0, 0, 0 };

test.c:255: note: create vector_type-pointer variable to type: vector(4) int*((int *) pretmp.699_10 + (unsigned int) ((unsigned int) j_54 * 16384))
test.c:255: note: created vect_p.727_123
test.c:255: note: add new stmt: MEM[(int *)vect_p.724_124] = vect_cst_.723_118;

test.c:255: note: ------>vectorizing statement: k_21 = k_61 + 1;

test.c:255: note: ------>vectorizing statement: ivtmp.709_16 = ivtmp.709_15 - 1;

test.c:255: note: ------>vectorizing statement: vect_p.724_125 = vect_p.724_124 + 16;

test.c:255: note: ------>vectorizing statement: if (ivtmp.709_16 != 0)

test.c:255: note: LOOP VECTORIZED.
test.c:260: note: ===== analyze_loop_nest =====
test.c:260: note: === vect_analyze_loop_form ===
test.c:260: note: ===== analyze_loop_nest_1 =====
test.c:260: note: === vect_analyze_loop_form ===
test.c:260: note: split exit edge.
test.c:260: note: === get_loop_niters ===
test.c:260: note: not vectorized: number of iterations cannot be computed.
test.c:260: note: bad inner-loop form.
test.c:260: note: not vectorized: Bad inner loop.
test.c:260: note: bad loop form.
test.c:261: note: ===== analyze_loop_nest =====
test.c:261: note: === vect_analyze_loop_form ===
test.c:261: note: === get_loop_niters ===
test.c:261: note: not vectorized: number of iterations cannot be computed.
test.c:261: note: bad loop form.
test.c:249: note: vectorized 1 loops in function.
cc timer.o barrier.o util.o simpletest.o test.o -o app -lpthread -ldrm_omap
